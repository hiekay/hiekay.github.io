<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hiekay&#39;s blog</title>
  
  <subtitle>分享技术的阳光地带</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hiekay.github.io/"/>
  <updated>2018-11-07T15:23:08.041Z</updated>
  <id>https://hiekay.github.io/</id>
  
  <author>
    <name>hiekay</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进入正在运行的Docker容器的4种方式</title>
    <link href="https://hiekay.github.io/2018/11/07/%E8%BF%9B%E5%85%A5%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84Docker%E5%AE%B9%E5%99%A8%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://hiekay.github.io/2018/11/07/进入正在运行的Docker容器的4种方式/</id>
    <published>2018-11-07T15:22:31.000Z</published>
    <updated>2018-11-07T15:23:08.041Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Docker创建了容器之后，如何进入该容器呢?</p><p>进入Docker容器比较常见的几种做法如下：</p><ul><li>使用docker attach</li><li>使用SSH</li><li>使用nsenter</li><li>使用exec</li></ul><h3 id="一、使用docker-attach进入Docker容器"><a href="#一、使用docker-attach进入Docker容器" class="headerlink" title="一、使用docker attach进入Docker容器"></a>一、使用docker attach进入Docker容器</h3><ul><li>Docker提供了attach命令来进入Docker容器。</li></ul><p>　　接下来我们创建一个守护态的Docker容器，然后使用docker attach命令进入该容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -itd ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure></p><p>　　然后我们使用docker ps查看到该容器信息，接下来就使用docker attach进入该容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker attach 容器ID</span><br></pre></td></tr></table></figure></p><p>但在，使用该命令有一个问题。当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作。<br>因为这个原因，所以docker attach命令不太适合于生产环境，平时自己开发应用时可以使用该命令。</p><h3 id="二、使用SSH进入Docker容器"><a href="#二、使用SSH进入Docker容器" class="headerlink" title="二、使用SSH进入Docker容器"></a>二、使用SSH进入Docker容器</h3><p>在生产环境中排除了使用docker attach命令进入容器之后，相信大家第一个想到的就是ssh。在镜像（或容器）中安装SSH Server，这样就能保证多人进入</p><p>容器且相互之间不受干扰了，相信大家在当前的生产环境中（没有使用Docker的情况）也是这样做的。但是使用了Docker容器之后不建议使用ssh进入到Docker容</p><p>器内。关于为什么不建议使用，请参考如下文章：</p><p><a href="http://www.oschina.net/translate/why-you-dont-need-to-run-sshd-in-docker?cmp" target="_blank" rel="noopener">为什么不需要在 Docker 容器中运行 sshd</a></p><h1 id="三、使用nsenter进入Docker容器"><a href="#三、使用nsenter进入Docker容器" class="headerlink" title="三、使用nsenter进入Docker容器"></a>三、使用nsenter进入Docker容器</h1><p>在上面两种方式都不适合的情况下，还有一种比较方便的方法，即使用nsenter进入Docker容器。关于什么是nsenter请参考如下文章：</p><p><a href="https://github.com/jpetazzo/nsenter" target="_blank" rel="noopener">https://github.com/jpetazzo/nsenter</a></p><p>在了解了什么是nsenter之后，系统默认将我们需要的nsenter安装到主机中</p><p>如果没有安装的话，按下面步骤安装即可（注意是主机而非容器或镜像）</p><p>具体的安装命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.  $ wget https://www.kernel.org/pub/linux/utils/util-linux/v2.24/util-linux-2.24.tar.gz  </span><br><span class="line">2.  $ tar -xzvf util-linux-2.24.tar.gz  </span><br><span class="line">3.  $ cd util-linux-2.24/  </span><br><span class="line">4.  $ ./configure --without-ncurses  </span><br><span class="line">5.  $ make nsenter  </span><br><span class="line">6.  $ sudo cp nsenter /usr/local/bin</span><br></pre></td></tr></table></figure></p><p>安装好nsenter之后可以查看一下该命令的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsenter --help</span><br></pre></td></tr></table></figure></p><p>　　nsenter可以访问另一个进程的名称空间。所以为了连接到某个容器我们还需要获取该容器的第一个进程的PID。可以使用docker inspect命令来拿到该PID。</p><p>docker inspect命令使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --help</span><br></pre></td></tr></table></figure></p><p>inspect命令可以分层级显示一个镜像或容器的信息。比如我们当前有一个正在运行的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure></p><p>可以使用docker inspect来查看该容器的详细信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect 44fc0f0582d9</span><br></pre></td></tr></table></figure></p><p>由其该信息非常多，此处只截取了其中一部分进行展示。如果要显示该容器第一个进行的PID可以使用如下方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect -f &#123;&#123;.State.Pid&#125;&#125; 44fc0f0582d9</span><br></pre></td></tr></table></figure></p><p>在拿到该进程PID之后我们就可以使用nsenter命令访问该容器了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nsenter --target 3326 --mount --uts --ipc --net --pid</span><br></pre></td></tr></table></figure></p><p>其中的3326即刚才拿到的进程的PID </p><p>当然，如果你认为每次都输入那么多参数太麻烦的话，网上也有许多做好的脚本供大家使用。</p><p>地址如下：</p><p><a href="http://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="noopener">http://yeasy.gitbooks.io/docker_practice/content/container/enter.html</a></p><p><a href="http://www.tuicool.com/articles/eYnUBrR" target="_blank" rel="noopener">http://www.tuicool.com/articles/eYnUBrR</a></p><h3 id="四、使用docker-exec进入Docker容器"><a href="#四、使用docker-exec进入Docker容器" class="headerlink" title="四、使用docker exec进入Docker容器**"></a>四、使用docker exec进入Docker容器**</h3><p>除了上面几种做法之外，docker在1.3.X版本之后还提供了一个新的命令exec用于进入容器，这种方式相对更简单一些，下面我们来看一下该命令的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker exec --help</span><br></pre></td></tr></table></figure></p><p>接下来我们使用该命令进入一个已经在运行的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.  $ sudo docker ps  </span><br><span class="line">2.  $ sudo docker exec -it 775c7c9ee1e1 /bin/bash</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Docker创建了容器之后，如何进入该容器呢?&lt;/p&gt;
&lt;p&gt;进入Docker容器比较常见的几种做法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用docker attach&lt;/li&gt;
&lt;li&gt;使用SSH&lt;/li&gt;
&lt;li&gt;使用nsenter&lt;/li&gt;
&lt;li&gt;使用exec&lt;/
      
    
    </summary>
    
      <category term="docker" scheme="https://hiekay.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://hiekay.github.io/tags/docker/"/>
    
      <category term="进入docker方法" scheme="https://hiekay.github.io/tags/%E8%BF%9B%E5%85%A5docker%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker测试静态网站</title>
    <link href="https://hiekay.github.io/2018/11/07/%E4%BD%BF%E7%94%A8Docker%E6%B5%8B%E8%AF%95%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/"/>
    <id>https://hiekay.github.io/2018/11/07/使用Docker测试静态网站/</id>
    <published>2018-11-07T15:21:43.000Z</published>
    <updated>2018-11-07T15:22:17.315Z</updated>
    
    <content type="html"><![CDATA[<p>下来是将Nginx安装到容器来架构一个简单的网站开发,网站命名为Sample.</p><h4 id="1-samle网站的初试Dockerfile"><a href="#1-samle网站的初试Dockerfile" class="headerlink" title="1.samle网站的初试Dockerfile"></a>1.samle网站的初试Dockerfile</h4><ul><li><p>为Nginx Dockerfile创建一个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir sample</span><br><span class="line">$ cd sample</span><br><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure></li><li><p>获取Nginx配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd sample</span><br><span class="line">$ mkdir nginx &amp;&amp; cd nginx </span><br><span class="line">$ wget https://github.com/hiekay/dockerbook-code/blob/master/code/5/sample/nginx/global.conf</span><br><span class="line">$ wget https://github.com/hiekay/dockerbook-code/blob/master/code/5/sample/nginx/nginx.conf</span><br><span class="line">$ cd ..</span><br></pre></td></tr></table></figure></li><li><p>网站测试的基本Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">MAINTAINER hiekay &quot;hikay5230@gmail.com&quot;</span><br><span class="line">ENV REFRESHED_AT 2018-11-2</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get -y -q install nginx</span><br><span class="line">RUN mkdir -p /var/www/html</span><br><span class="line">ADD nginx/global.conf /etc/nginx/conf.d/</span><br><span class="line">ADD nginx/nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure></li><li><p>解析: dockerfile 包括:<br>安装Nginx;<br>在容器中创建一个目录/var/www/html;<br>将来自本地文件的Nginx配置文件添加到镜像中;<br>公开镜像80端口.</p></li><li>global.conf文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen          0.0.0.0:80;</span><br><span class="line">        server_name     _;</span><br><span class="line"></span><br><span class="line">        root            /var/www/html/website;</span><br><span class="line">        index           index.html index.htm;</span><br><span class="line"></span><br><span class="line">        access_log      /var/log/nginx/default_access.log;</span><br><span class="line">        error_log       /var/log/nginx/default_error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>网站根目录: root  /var/www/html/website;</p><ul><li>nginx.conf配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes 4;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">daemon off;</span><br><span class="line"></span><br><span class="line">events &#123;  &#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  sendfile on;</span><br><span class="line">  tcp_nopush on;</span><br><span class="line">  tcp_nodelay on;</span><br><span class="line">  keepalive_timeout 65;</span><br><span class="line">  types_hash_max_size 2048;</span><br><span class="line">  include /etc/nginx/mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line">  access_log /var/log/nginx/access.log;</span><br><span class="line">  error_log /var/log/nginx/error.log;</span><br><span class="line">  gzip on;</span><br><span class="line">  gzip_disable &quot;msie6&quot;;</span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-构建Sample网站和Nginx镜像"><a href="#2-构建Sample网站和Nginx镜像" class="headerlink" title="2.构建Sample网站和Nginx镜像"></a>2.构建Sample网站和Nginx镜像</h4><ul><li><p>构建新的Nginx镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build -t hiekay/nginx .</span><br></pre></td></tr></table></figure></li><li><p>展示Nginx镜像的构建历史</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker history hiekay/nginx   </span><br><span class="line"></span><br><span class="line">//返回</span><br><span class="line">IMAGE               CREATED              CREATED BY                                      SIZE                COMMENT</span><br><span class="line">c2f93099a450        About a minute ago   /bin/sh -c #(nop)  EXPOSE 80                    0B                  </span><br><span class="line">79e5c47816c2        About a minute ago   /bin/sh -c #(nop) ADD file:ae1b9b338d442b9bc…   415B                </span><br><span class="line">4e375527ddd7        About a minute ago   /bin/sh -c #(nop) ADD file:e570a7cbab1d98b88…   286B                </span><br><span class="line">16ef3bfd3dcd        About a minute ago   /bin/sh -c mkdir -p /var/www/html               0B                  </span><br><span class="line">41f4aad7a454        2 minutes ago        /bin/sh -c apt-get -y -q install nginx          59.7MB              </span><br><span class="line">1a50f2d65b09        2 minutes ago        /bin/sh -c apt-get update                       23.8MB              </span><br><span class="line">d02ebf320b6c        3 minutes ago        /bin/sh -c #(nop)  ENV REFRESHED_AT=2018-11-2   0B                  </span><br><span class="line">a1eda1cd7dfe        27 hours ago         /bin/sh -c #(nop)  MAINTAINER hiekay &quot;hikay5…   0B                  </span><br><span class="line">ea4c82dcd15a        2 weeks ago          /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line">&lt;missing&gt;           2 weeks ago          /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;do…   7B                  </span><br><span class="line">&lt;missing&gt;           2 weeks ago          /bin/sh -c rm -rf /var/lib/apt/lists/*          0B                  </span><br><span class="line">&lt;missing&gt;           2 weeks ago          /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /…   745B                </span><br><span class="line">&lt;missing&gt;           2 weeks ago          /bin/sh -c #(nop) ADD file:bcd068f67af2788db…   85.8MB</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-从Sample网站和Nginx镜像构建容器"><a href="#3-从Sample网站和Nginx镜像构建容器" class="headerlink" title="3.从Sample网站和Nginx镜像构建容器"></a>3.从Sample网站和Nginx镜像构建容器</h4><ul><li>下载Sample网站<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd sample</span><br><span class="line">$ mkdir website &amp;&amp; cd website</span><br><span class="line">$ wget https://github.com/hiekay/dockerbook-code/blob/master/code/5/sample/website/index.html</span><br><span class="line">$ cd ..</span><br></pre></td></tr></table></figure></li></ul><p>其中 index.html 内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;title&gt;Test website&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;This is a test website&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><ul><li>构建一个Nginx测试容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 80 --name website -v $PWD/website:/var/www/html/website hiekay/nginx nginx</span><br></pre></td></tr></table></figure></li></ul><p>其中 -v 是指定卷的位置<br>卷的使用场景:<br>希望同事对代码做开发和测试;<br>代码改动很频繁,不想在开发过程中重构镜像;<br>希望在多个容器间共享代码.</p><ul><li><p>控制卷的写状态:<br>rw : 读写<br>ro : 只读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo docker run -d -p 80 --name website -v $PWD/website:/var/www.html/website:ro hiekay/nginx nginx</span><br></pre></td></tr></table></figure></li><li><p>查看Sample网站容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l            </span><br><span class="line">                                                                   </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">dc1a45694b4b        hiekay/nginx        &quot;nginx&quot;             4 minutes ago       Up 4 minutes        0.0.0.0:32769-&gt;80/tcp   website</span><br></pre></td></tr></table></figure></li></ul><p>在宿主机上浏览32769端口,看到网站如下:<br><img src="https://upload-images.jianshu.io/upload_images/5110710-b073ca0092b6949c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="4-修改网站"><a href="#4-修改网站" class="headerlink" title="4.修改网站"></a>4.修改网站</h4><ul><li>修改sample网站<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi $PWD/website/index.html</span><br></pre></td></tr></table></figure></li></ul><p>将内容换成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is a test website for docker .</span><br></pre></td></tr></table></figure></p><p>刷新浏览器 , 如下 :<br><img src="https://upload-images.jianshu.io/upload_images/5110710-a6c2af704d7de114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以看到网站已经更新了.</p><ul><li><p>总结:可以实现正在测试的网站的运行环境,完全是生产环境里的真实状态.<br>可以给每个用于生产的网站服务环境配置一个容器,给不同的开发框架的运行环境配置一个容器,或者给后端数据库配置一个容器.等.</p></li><li><p>注意  可以进容器内查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker exec -t -i 容器ID /bin/bash</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下来是将Nginx安装到容器来架构一个简单的网站开发,网站命名为Sample.&lt;/p&gt;
&lt;h4 id=&quot;1-samle网站的初试Dockerfile&quot;&gt;&lt;a href=&quot;#1-samle网站的初试Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
      <category term="docker" scheme="https://hiekay.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://hiekay.github.io/tags/docker/"/>
    
      <category term="Docker测试静态网站" scheme="https://hiekay.github.io/tags/Docker%E6%B5%8B%E8%AF%95%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>Docker的Dockerfile指令</title>
    <link href="https://hiekay.github.io/2018/11/07/Docker%E7%9A%84Dockerfile%E6%8C%87%E4%BB%A4/"/>
    <id>https://hiekay.github.io/2018/11/07/Docker的Dockerfile指令/</id>
    <published>2018-11-07T15:21:08.000Z</published>
    <updated>2018-11-07T15:21:28.075Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h4><ul><li><p>(1) CMD<br>用于指定一个容器启动时要运行的命令.<br>类似RUN</p><ul><li><p>指定要运行的特定命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -i -t hiekay/static_web /bin/true</span><br></pre></td></tr></table></figure></li><li><p>使用CMD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;/bin/true&quot;]</span><br></pre></td></tr></table></figure></li><li><p>给CMD指令传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;/bin/bash&quot;, &quot;-l&quot;]</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>将-l 标志传递给/bin/bash命令.<br>docker run  命令可以覆盖CMD命令</p><ul><li>(2) ENTRYPOINT<br>ENTRYPOINT 和CMD命令类似,但是不容易在启动的时候被覆盖.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/sbin/nginx&quot;]</span><br></pre></td></tr></table></figure></li></ul><p>指定参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot; ]</span><br></pre></td></tr></table></figure></p><ul><li>(3) WORKDIR<br>WORKDIR指令用来在从镜像创建一个新容器时,在容器内部设置一个工作目录,ENTRYPOINT或者CMD指定的程序会在这个目录下执行.<br>如 使用WORKDIR命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /opt/webapp/db</span><br><span class="line">RUN bundle install</span><br><span class="line">WORKDIR /opt/webapp</span><br><span class="line">ENTRYPOINT [&quot;rackup&quot;]</span><br></pre></td></tr></table></figure></li></ul><p>我们将目录切换为/opt/webapp/db 后运行bundle install , 之后将目录切换为/opt/webapp,最后设置ENTRYPOINT指令来启动rackup命令.</p><p> 可以通过-w标志在运行时候覆盖工作目录</p><ul><li>覆盖工作目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -ti -w /var/log ubuntu pwd</span><br></pre></td></tr></table></figure></li></ul><p>该命令会将容器内的工作目录设置为/var/log . </p><ul><li>(4) ENV<br>ENV指令用来在镜像构建过程中设置环境变量.</li><li><p>在Dockerfile文件中设置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV RVM_PATH /home/rvm/</span><br></pre></td></tr></table></figure></li><li><p>为RUN指令设置前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN gem install unicorn</span><br></pre></td></tr></table></figure></li><li><p>添加ENV 前缀后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RVM_PATH=/home/rvm/ gem install unicorn</span><br></pre></td></tr></table></figure></li><li><p>在其他Dockerfile指令中使用环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV TARGET_DIR /opt/app</span><br><span class="line">WORKDIR $TARGET_DIR</span><br></pre></td></tr></table></figure></li></ul><p>在这里我们设定了一个新的环境变量TARGET_DIR, 并在WORKDIR中使用了它的值,因此实际上WORKDIR指令的值会被设置为/opt/app  </p><ul><li><p>(5) USER<br>USER 指令用来指定该镜像会以什么用户去运行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER nginx</span><br></pre></td></tr></table></figure><ul><li>指定USER和GROUP的各种组合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>也可以在docker run 命令通过-u选项覆盖该指令的值.</p><ul><li>(6) VOLUME<br>VOLUME指令用来向基于镜像创建的容器添加卷.<ul><li>使用VOLUME指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/opt/project&quot;]</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>这个指令会为基于此镜像创建的任何容器创建一个名为 /opt/project 的挂载点.</p><ul><li>使用VOLUME指令指定多个卷<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/opt/project&quot;, &quot;/data&quot; ]</span><br></pre></td></tr></table></figure></li></ul><ul><li>(7)ADD<br>ADD指令用来将构建环境下的文件和目录复制到镜像中.<br>如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD software.lic /opt/application/software.lic</span><br></pre></td></tr></table></figure></li></ul><p>解析:ADD指令将会将构建目录下的software.lic文件复制到镜像中的/opt/application/software.lic </p><ul><li>在ADD指令中使用URL作为文件源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD http://wordpress.org/latest.zip /root/wordpress.zip</span><br></pre></td></tr></table></figure></li></ul><ul><li>将归档文件作为ADD指令中的源文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD latest.tar.gz /var/www/wordpress</span><br></pre></td></tr></table></figure></li></ul><p>会自动解压到目录下.</p><ul><li>(8)COPY<br>COPY指令非常类似ADD 不同是COPY只关心在构建上下文中复制本地文件,而不会去做文件提取和解压.</li><li>使用COPY指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY conf.d /etc/apache2</span><br></pre></td></tr></table></figure></li></ul><p>将 本地 conf.d目录中的文件复制到/etc/apache2目录中.</p><ul><li>(9) ONBUILD<br>ONBUILD 指令能为镜像添加触发器.当一个镜像被用做其他镜像的基础镜像时,该镜像中的触发器将会被执行.</li><li><p>添加ONBUILD指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN cd /app/src &amp;&amp; make</span><br></pre></td></tr></table></figure></li><li><p>通过docker inspect 命令查看镜像中的ONBUILD命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect ID</span><br></pre></td></tr></table></figure></li><li><p>新的ONBUILD镜像Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#Version: 0.0.1</span><br><span class="line">FROM ubuntu:18.04</span><br><span class="line">MAINTAINER hiekay &quot;hikay5230@gmail.com&quot;</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y apache2</span><br><span class="line">ENV APACHE_RUN_USER www-data</span><br><span class="line">ENV APACHE_RUN_GROUP www-data</span><br><span class="line">ENV APACHE_LOG_DIR /var/log/apche2</span><br><span class="line">ONBUILD ADD . /var/www/</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTRYPOINT [&quot;/usr/sbin/apache2&quot;]</span><br><span class="line">CMD [&quot;-D&quot;, &quot;FOREGROUND&quot;]</span><br></pre></td></tr></table></figure><ul><li>构建apche2镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -t=&quot;hiekay/apache2&quot; .</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>解析:在新构建的镜像中包含一条ONBUILD指令, 该指令将构建环境所在的目录下的内容全部添加到镜像中的/var/www/目录小.我们将这个Dockerfile 作为一个通用的Web应用程序的模板,可以基于这个模板来构建Web应用程序.</p><ul><li><p>构建webapp的Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM hiekay/apache2</span><br><span class="line">MAINTAINER hiekay &quot;hikay5230@gmail.com&quot;</span><br><span class="line">ENV APPLICATION_NAME webapp</span><br><span class="line">ENV ENVIRONMENT development</span><br></pre></td></tr></table></figure></li><li><p>构建webapp镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -t=&quot;hiekay/webapp&quot; .</span><br></pre></td></tr></table></figure></li></ul><p>这个构建过程就会基于hiekay/apache2镜像,就会执行ADD指令.  因为ADD 指令就是在ONBUILD 触发器中指定的.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Dockerfile指令&quot;&gt;&lt;a href=&quot;#Dockerfile指令&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile指令&quot;&gt;&lt;/a&gt;Dockerfile指令&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;(1) CMD&lt;br&gt;用于指定一个容器启动
      
    
    </summary>
    
      <category term="docker" scheme="https://hiekay.github.io/categories/docker/"/>
    
    
      <category term="Dockerfile" scheme="https://hiekay.github.io/tags/Dockerfile/"/>
    
      <category term="docker" scheme="https://hiekay.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>构建docker镜像</title>
    <link href="https://hiekay.github.io/2018/11/07/%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F/"/>
    <id>https://hiekay.github.io/2018/11/07/构建docker镜像/</id>
    <published>2018-11-07T15:20:16.000Z</published>
    <updated>2018-11-07T15:20:48.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-创建Docker-Hub账号"><a href="#1-创建Docker-Hub账号" class="headerlink" title="1.创建Docker Hub账号"></a>1.创建Docker Hub账号</h4><p>网址:<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 注册.</p><ul><li>登录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker login</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-用docker-commit命令创建镜像"><a href="#2-用docker-commit命令创建镜像" class="headerlink" title="2.用docker commit命令创建镜像"></a>2.用docker commit命令创建镜像</h4><ul><li><p>创建一个要进行修改的定制容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t ubuntu /bin/bash                   </span><br><span class="line">root@7dfcf4332617:/#</span><br></pre></td></tr></table></figure></li><li><p>在容器中安装apache软件包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@7dfcf4332617:/# apt-get -yqq update</span><br><span class="line">root@7dfcf4332617:/# apt-get -y install apache2</span><br></pre></td></tr></table></figure></li><li><p>提交定制容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker commit 7dfcf4332617 hiekay/apache2</span><br></pre></td></tr></table></figure></li><li><p>检查新创建的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images hiekay/apache2   </span><br><span class="line">          </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">hiekay/apache2      latest              d36fa6c04e5b        About a minute ago   205MB</span><br></pre></td></tr></table></figure></li><li><p>提交另一个新的定制容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker commit -m=&quot;A new custom image&quot; --author=&quot;hiekay&quot; 7dfcf4332617 hiekay/apache2:webserver</span><br></pre></td></tr></table></figure></li></ul><p>解析:<br>-m 指定提交信息,–author指定作者信息, ID:7dfcf4332617 ,hiekay/apache2 用户名和仓库名, 标签:webserver</p><ul><li><p>查看镜像的详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect  hiekay/apache2:webserver                                                      </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:dfda6a2c29aac1aa25b188f5b5f1a8b0d6cf63c92df0bacb4f062be312ebe9c2&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;hiekay/apache2:webserver&quot;</span><br><span class="line">        ],</span><br><span class="line">........</span><br></pre></td></tr></table></figure></li><li><p>运行新容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t hiekay/apache2:webserver /bin/bash</span><br><span class="line">root@b7a12bac939e:/#</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-用Dockerfile创建镜像"><a href="#3-用Dockerfile创建镜像" class="headerlink" title="3.用Dockerfile创建镜像"></a>3.用Dockerfile创建镜像</h4><p>用Dockerfile的自定义文件和docker build 命令来构建镜像.Dockerfile使用基本的基于DSL语法的指令来构建一个Docker镜像,之后使用docker build命令基于该Dockerfile中的指令构建一个新的镜像.</p><h5 id="创建第一个Dockerfile"><a href="#创建第一个Dockerfile" class="headerlink" title="创建第一个Dockerfile"></a>创建第一个Dockerfile</h5><ul><li>创建一个示例仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir static_web</span><br><span class="line">$ cd static_web</span><br><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure></li></ul><p>目录static_web 用来保存Dockefile ,这个目录也是我们的构建环境, Docker称此环境为上下文或者构建上下文. Docker 会在构建镜像时将构建上下文和该上下文中的文件和目录上传到Docker守护进程.</p><ul><li>第一个Dockerfile<br>例子: 创建一个空Dockerfile,通过Dockerfile 构建一个能作为Web服务器的Docker镜像.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#Version: 0.0.1</span><br><span class="line">FROM ubuntu:18.04</span><br><span class="line">MAINTAINER hiekay &quot;hikay5230@gmail.com&quot;</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">RUN echo &apos;Hi,I am in your container&apos; &gt; /usr/share/nginx/html/index.html</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure></li></ul><p>该Dockerfile由一系列指令和参数组成.<br>每条指令,如FROM都必须大写,后面跟一个参数.<br>指令会按顺序从上到下执行.<br>每条指令都会去创建一个新的镜像层并对镜像进行提交.</p><h5 id="流程"><a href="#流程" class="headerlink" title="流程:"></a>流程:</h5><ul><li>Docker从基础镜像运行一个容器.</li><li>执行一条指令,对容器做出修改.</li><li>执行类似docker commit 的操作,提交一个新的镜像层.</li><li>Docker再基于刚提交的镜像运行一个新容器.</li><li>执行Dockerfile中的下一个指令,直到所有指令都执行完毕.<br>所以,如果Dockerfile某些原因(某指令失败了)没有正常结束.也将得到一个可以使用的镜像.<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5></li><li>每个Docker的第一条指令都应该是FROM,FROM指令指定了一个已经存在的镜像,后续指令都将基于该镜像进行,这个镜像被称为基础镜像.</li><li>MAINTAINER指令设置作者和邮箱</li><li>RUN指令,会在当前镜像中运行指定的命令,默认RUN指令会在shell中使用命令包装器/bin/sh -c 运行. 如果是在一个不支持shell的平台或者不希望在shell中运行,可以用exec 格式的RUN指令<br>如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ &quot;apt-get&quot;, &quot; install &quot;, &quot;-y&quot;, &quot;nginx&quot; ]</span><br></pre></td></tr></table></figure></li></ul><p>在这种方式中,使用一个数组来指定要运行的命令和传递给该命令的每个参数.</p><ul><li>EXPOSE指令,是设置容器的指定端口. 也可以指定多个端口.<h4 id="4-基于Dockerfile构建新镜像"><a href="#4-基于Dockerfile构建新镜像" class="headerlink" title="4.基于Dockerfile构建新镜像"></a>4.基于Dockerfile构建新镜像</h4>执行docker build 命令时,Dockerfile中的所有命令都会执行并提交,成功结束后返回一个新镜像.</li><li>运行Dockerfile<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cd static_web</span><br><span class="line">$ sudo docker build -t=&quot;hiekay/static_web&quot; . </span><br><span class="line">//开始运行</span><br><span class="line">sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/6 : FROM ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">Digest: sha256:29934af957c53004d7fb6340139880d23fb1952505a15d69a03af0d1418878cb</span><br><span class="line">Status: Downloaded newer image for ubuntu:18.04</span><br><span class="line"> ---&gt; ea4c82dcd15a</span><br><span class="line">Step 2/6 : MAINTAINER hiekay &quot;hikay5230@gmail.com&quot;</span><br><span class="line"> ---&gt; Running in 82ebf098abd8</span><br><span class="line">Removing intermediate container 82ebf098abd8</span><br><span class="line"> ---&gt; b8405a62db26</span><br><span class="line">Step 3/6 : RUN apt-get update</span><br></pre></td></tr></table></figure></li></ul><p>其中 -t 选项设置了仓库和名称.<br>还可以设置标签:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -t=&quot;hiekay/static_web:v1&quot; .</span><br></pre></td></tr></table></figure></p><p>如果不设置标签,默认标签是latest标签.<br>命令最后的 .  告诉Docker到本地目录去找Dockerfile , 也可以指定一个git 仓库的源地址来指定Dockerfile的地址<br>如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -t=&quot;hiekay/static_web:v1&quot; git@github.com:hiekay/docker-static-_web</span><br></pre></td></tr></table></figure></p><p>在该git仓库根目录下存折Dockerfile文件.<br>其中:<br>sending build context to Docker daemon  2.048kB<br>是将构建上下文上传到Docker守护进程.</p><ul><li>注意:<br>如果在构建上下文的根目录下存在.dockerignore命名的文件, 这个该文件用来设置哪些文件不会被上传到构建上下文中.<h4 id="5-指令失败时会怎样"><a href="#5-指令失败时会怎样" class="headerlink" title="5.指令失败时会怎样"></a>5.指令失败时会怎样</h4>假如在第四部写错了:ngin<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cd static_web</span><br><span class="line">$ sudo docker build -t=&quot;hiekay/static_web&quot; . </span><br><span class="line">//开始运行</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/6 : FROM ubuntu:18.04</span><br><span class="line"> ---&gt; ea4c82dcd15a</span><br><span class="line">Step 2/6 : MAINTAINER hiekay &quot;hikay5230@gmail.com&quot;</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; b8405a62db26</span><br><span class="line">Step 3/6 : RUN apt-get update</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; a7b7791c3818</span><br><span class="line">Step 4/6 : RUN apt-get install -y ngin</span><br><span class="line"> ---&gt; Running in fabeeceeefe2</span><br><span class="line">Reading package lists...</span><br><span class="line">Building dependency tree...</span><br><span class="line">Reading state information...</span><br><span class="line">E: Unable to locate package ngin</span><br><span class="line">The command &apos;/bin/sh -c apt-get install -y ngin&apos; returned a non-zero code: 100</span><br></pre></td></tr></table></figure></li></ul><p>报错,E: Unable to locate package ngin<br>最后成功的一层ID是:a7b7791c3818</p><ul><li>基于最后成功步骤创建新容器<br>再运行:  apt-get install -y ngin 并指定正确的包名,进一步调试,解决问题.就可以退出容器了,使用正确的报名修改Dockerfile,之后再进行构建.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t a7b7791c3818 /bin/bash</span><br><span class="line">root@9988a4ab2845:/# </span><br><span class="line">root@9988a4ab2845:/# apt-get install -y ngin</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-Dockerfile-和构建缓存"><a href="#6-Dockerfile-和构建缓存" class="headerlink" title="6.Dockerfile 和构建缓存"></a>6.Dockerfile 和构建缓存</h4><p>因为每一步的构建过程都会将结果提交为镜像,所以它会将之前的镜像层看做缓存.</p><ul><li>忽略Dockerfile的构建缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build --no-cache -t=&quot;hiekay/static_web&quot; .</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-基于构建缓存的Dockerfile模板"><a href="#7-基于构建缓存的Dockerfile模板" class="headerlink" title="7.基于构建缓存的Dockerfile模板"></a>7.基于构建缓存的Dockerfile模板</h4><p>构建缓存的好处是可以实现简单的Dockerfile模板.在自己的Dockerfile文件顶部使用相同的指令模板,比如Ubuntu.</p><ul><li><p>Ubuntu系统的Dockerfile模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Version: 0.0.1</span><br><span class="line">FROM ubuntu:18.04</span><br><span class="line">MAINTAINER hiekay &quot;hikay5230@gmail.com&quot;</span><br><span class="line">ENV REFRESHED_AT 2018-11-1</span><br><span class="line">RUN apt-get -qq update</span><br></pre></td></tr></table></figure></li><li><p>解析:<br>首先通过FROM指令为镜像设置基础镜像Ubuntu:18.04 , 然后使用MAINTAINER 添加自己的信息. 之后使用 ENV 设置 环境变量.设置REFRESHED_AT的环境变量用来表示该镜像模板最后的更新时间 .最后使用RUN指令运行apt-get -qq update 命令. 该指令运行时将会刷新APT包的缓存,用来确保我们能将要安装的每个软件包都更新到最新版本.</p></li></ul><p>有了这个模板,如果想刷新一个构建,只需要修改ENV指令中的日期.这使Docker在命令ENV指令时开始重置这个缓存,并运行后续指令无须依赖该缓存. 也就是说, RUN apt-get update 这条指令将会被再次执行,包缓存也将会被刷新为最新内容.<br>可以扩展此模板,比如适配到不同的平台或者添加额外的需求.</p><ul><li>比如支持Fedora Dockerfile模板<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM fedora:20</span><br><span class="line">MAINTAINER hiekay &quot;hikay5230@gmail.com&quot;</span><br><span class="line">ENV REFRESHED_AT 2018-11-1</span><br><span class="line">RUN yum -y -q upgrade</span><br></pre></td></tr></table></figure></li></ul><p>在Fedora中使用Yum实现了与上面的Ubuntu例子中非常类似的功能.</p><h4 id="8-查看新镜像"><a href="#8-查看新镜像" class="headerlink" title="8.查看新镜像"></a>8.查看新镜像</h4><ul><li>列出新的Docker镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images hiekay/static_web</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hiekay/static_web   latest              7e35e0a7fc62        3 hours ago         169MB</span><br></pre></td></tr></table></figure></li></ul><p>深入探究镜像是如何构建出来的,使用docker history命令</p><ul><li>使用docker history 命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker history 7e35e0a7fc62  </span><br><span class="line"></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">7e35e0a7fc62        3 hours ago         /bin/sh -c #(nop)  EXPOSE 80                    0B                  </span><br><span class="line">2f6d2e9be7ac        3 hours ago         /bin/sh -c echo &apos;Hi,I am in your container&apos; …   26B                 </span><br><span class="line">4c7337c294ac        3 hours ago         /bin/sh -c apt-get install -y nginx             59.7MB              </span><br><span class="line">489c8164d6af        3 hours ago         /bin/sh -c apt-get update                       23.8MB              </span><br><span class="line">c8288775012d        3 hours ago         /bin/sh -c #(nop)  MAINTAINER hiekay &quot;hikay5…   0B                  </span><br><span class="line">ea4c82dcd15a        13 days ago         /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo &apos;do…   7B                  </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c rm -rf /var/lib/apt/lists/*          0B                  </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c set -xe   &amp;&amp; echo &apos;#!/bin/sh&apos; &gt; /…   745B                </span><br><span class="line">&lt;missing&gt;           13 days ago         /bin/sh -c #(nop) ADD file:bcd068f67af2788db…   85.8MB</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-从新镜像启动一个容器"><a href="#9-从新镜像启动一个容器" class="headerlink" title="9.从新镜像启动一个容器"></a>9.从新镜像启动一个容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 80 --name static_web hiekay/static_web nginx -g &quot;daemon off;&quot;</span><br><span class="line">09bb5531cbc24930ad35da95dd0acd52dd933c5996ae89e238b509053b7f8c1d</span><br></pre></td></tr></table></figure><ul><li>解析:<br>docker run命令运行一个名字为static_web的新容器, -d 选项,告诉Docker以分离(detached)的方式在后台运行.适合运行类似Nginx守护进程这样的需要长时间运行的进程. 并指定了需要在容器中运行的命令:nginx -g “daemon off;” 这将以前台运行的方式启动nginx 来作为我们的Web服务器.<br>其中-p标志,用来控制Docker公开哪些网络端口给外部宿主机.<br>两种方法分配端口:</li><li>Docker可以在宿主机上随机选择一个位于49153~65535的一个比较大的端口号来映射到容器中80端口上.</li><li><p>可以在Docker宿主机中指定一个具体的端口号来映射到容器中的80端口上.</p></li><li><p>查看Docker端口映射情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l</span><br></pre></td></tr></table></figure></li><li><p>dockerport 命令查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker port 09bb5531cbc2 80</span><br><span class="line">                                                  </span><br><span class="line">80/tcp -&gt; 127.0.0.1:32768</span><br></pre></td></tr></table></figure></li><li><p>通过-p选项映射到特定端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 80:80 --name static_web hiekay/static_web nginx -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure></li><li><p>绑定不同的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 8080:80 --name static_web hiekay/static_web nginx -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure></li><li><p>绑定到特定的网络接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1:80:80 --name static_web hiekay/static_web nginx -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure></li></ul><p>绑定到了宿主机127.0.0.1这个IP的80端口上.</p><ul><li><p>绑定到特定的网络接口的随机端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1::80 --name static_web hiekay/static_web nginx -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure></li><li><p>扩展<br>可以使用 /udp后缀指定UDP端口</p></li></ul><p>其中提供参数-P 用来对外公开在Dockerfile中的EXPOSE指令中设置的所有端口</p><ul><li>使用docker run命令对外公开端口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P --name static_web hiekay/static_web nginx -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure></li></ul><p>该命令会将容器内的80端口对本地宿主机公开,绑定宿主机的随机端口. 会将用来构建该镜像的Dockerfile文件中EXPOSE指令指定的其他端口也公开.</p><p>有了这个端口号,我们可以用本地宿主机IP或者127.0.0.1的localhost 链接到运行中的容器了. </p><ul><li>使用curl连接到容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:32768</span><br><span class="line"></span><br><span class="line">//成功返回:</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-将镜像推送到Docker-Hub"><a href="#10-将镜像推送到Docker-Hub" class="headerlink" title="10.将镜像推送到Docker Hub"></a>10.将镜像推送到Docker Hub</h4><ul><li>docker push<br>推送Docker镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker push hiekay/static_web</span><br><span class="line"></span><br><span class="line">The push refers to repository [docker.io/hiekay/static_web]</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ul><p>成功后,可以在Docker Hub上看到我们上传的镜像.<br><img src="https://upload-images.jianshu.io/upload_images/5110710-1c81eded5fd8114b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="11-删除镜像"><a href="#11-删除镜像" class="headerlink" title="11.删除镜像"></a>11.删除镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi hiekay/static_web</span><br></pre></td></tr></table></figure><p>如果要删除一个Docker Hub上的镜像仓库,需要登录Docker Hub后使用Delete repository链接来删除.<br><img src="https://upload-images.jianshu.io/upload_images/5110710-57b5f9669388d3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>删除所有镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi &apos;docker images -a -q&apos;</span><br></pre></td></tr></table></figure></li></ul><h4 id="12-运行自己的Docker-Registry"><a href="#12-运行自己的Docker-Registry" class="headerlink" title="12.运行自己的Docker Registry"></a>12.运行自己的Docker Registry</h4><ul><li><p>运行基于容器的Registry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 5000:5000 registry</span><br></pre></td></tr></table></figure></li><li><p>查看hiekay/static_web</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images hiekay/static_web</span><br></pre></td></tr></table></figure></li><li><p>使用新的Registry 为镜像打标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker tag 某个ID docker.example.com:5000/hiekay/static_web</span><br></pre></td></tr></table></figure></li><li><p>将镜像推送到新Registry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push docker.example.com:5000/hiekay/static_web</span><br></pre></td></tr></table></figure></li><li><p>从本地Registry构建新的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -t -i docker.example.com:5000/hiekay/static_web /bin/bash</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-创建Docker-Hub账号&quot;&gt;&lt;a href=&quot;#1-创建Docker-Hub账号&quot; class=&quot;headerlink&quot; title=&quot;1.创建Docker Hub账号&quot;&gt;&lt;/a&gt;1.创建Docker Hub账号&lt;/h4&gt;&lt;p&gt;网址:&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="docker" scheme="https://hiekay.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://hiekay.github.io/tags/docker/"/>
    
      <category term="构建docker镜像" scheme="https://hiekay.github.io/tags/%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker镜像和仓库</title>
    <link href="https://hiekay.github.io/2018/11/07/%E4%BD%BF%E7%94%A8Docker%E9%95%9C%E5%83%8F%E5%92%8C%E4%BB%93%E5%BA%93/"/>
    <id>https://hiekay.github.io/2018/11/07/使用Docker镜像和仓库/</id>
    <published>2018-11-07T15:19:41.000Z</published>
    <updated>2018-11-07T15:20:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习了安装Docker 和 docker 的一些管理docker容器的命令。<br>回顾一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t --name another_container ubuntu /bin/bash        </span><br><span class="line">root@fbb219828a49:/#</span><br></pre></td></tr></table></figure></p><h4 id="1-列出镜像"><a href="#1-列出镜像" class="headerlink" title="1.列出镜像"></a>1.列出镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images         </span><br><span class="line">                                           </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              ea4c82dcd15a        12 days ago         85.8MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        7 weeks ago         1.84kB</span><br></pre></td></tr></table></figure><h4 id="2-拉取Ubuntu镜像"><a href="#2-拉取Ubuntu镜像" class="headerlink" title="2.拉取Ubuntu镜像"></a>2.拉取Ubuntu镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull ubuntu</span><br></pre></td></tr></table></figure><h4 id="3-查找镜像"><a href="#3-查找镜像" class="headerlink" title="3.查找镜像"></a>3.查找镜像</h4><p>查找所有在Docker Hub上的公共的可用镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker search puppet</span><br></pre></td></tr></table></figure></p><p>会查找所有带有puppet的镜像.</p><h4 id="4-构建镜像"><a href="#4-构建镜像" class="headerlink" title="4.构建镜像"></a>4.构建镜像</h4><ul><li>docker commit 命令</li><li>docker build 命令 和 Dockerfile 文件<br>下一节具体讲构建镜像</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面学习了安装Docker 和 docker 的一些管理docker容器的命令。&lt;br&gt;回顾一下&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="docker" scheme="https://hiekay.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://hiekay.github.io/tags/docker/"/>
    
      <category term="Docker镜像和仓库" scheme="https://hiekay.github.io/tags/Docker%E9%95%9C%E5%83%8F%E5%92%8C%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="https://hiekay.github.io/2018/11/07/Docker%E5%85%A5%E9%97%A8/"/>
    <id>https://hiekay.github.io/2018/11/07/Docker入门/</id>
    <published>2018-11-07T15:18:51.000Z</published>
    <updated>2018-11-07T15:19:24.508Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-测试docker是否存在"><a href="#1-测试docker是否存在" class="headerlink" title="1.测试docker是否存在"></a>1.测试docker是否存在</h4><ul><li>sudo docker info<br>返回docker的基本信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker info</span><br><span class="line">//出现一下内容</span><br><span class="line">Containers: 2</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 2</span><br><span class="line">Images: 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-运行第一个容器"><a href="#2-运行第一个容器" class="headerlink" title="2.运行第一个容器"></a>2.运行第一个容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t ubuntu /bin/bash</span><br><span class="line">//开始下载容器并运行</span><br><span class="line">Unable to find image &apos;ubuntu:latest&apos; locally</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">473ede7ed136: Pull complete </span><br><span class="line">c46b5fa4d940: Pull complete </span><br><span class="line">93ae3df89c92: Pull complete </span><br><span class="line">6b1eed27cade: Pull complete </span><br><span class="line">Digest: sha256:29934af957c53004d7fb6340139880d23fb1952505a15d69a03af0d1418878cb</span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br><span class="line">root@363ed45619ae:/#</span><br></pre></td></tr></table></figure><ul><li>注意 可通过 docker help  或者  man  docker-run 来获取 docker的命令列表</li><li><p>解析：<br> sudo docker run -i -t ubuntu /bin/bash<br> 其中-i 标志保证容器中STDIN是开启的，持久的标准输入，-t标志是告诉docker为要创建的容器分配一个伪tty终端。 Ubuntu是 创建一个Ubuntu镜像，同时告诉新容器中要运行：/bin/bash 命令。所以就到：root@363ed45619ae:/#    。</p><h4 id="3-使用容器"><a href="#3-使用容器" class="headerlink" title="3.使用容器"></a>3.使用容器</h4><p>其中容器ID 363ed45619ae 。 也是它的主机名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@363ed45619ae:/home# hostname</span><br><span class="line">363ed45619ae</span><br><span class="line">root@363ed45619ae:/home# cat /etc/hosts</span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">ff00::0ip6-mcastprefix</span><br><span class="line">ff02::1ip6-allnodes</span><br><span class="line">ff02::2ip6-allrouters</span><br><span class="line">172.17.0.2363ed45619ae</span><br></pre></td></tr></table></figure></li><li><p>网络配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@363ed45619ae:/home# ip a</span><br></pre></td></tr></table></figure></li><li><p>检查容器进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@363ed45619ae:/home# ps -aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0  18508  3428 pts/0    Ss   07:34   0:00 /bin/bash</span><br><span class="line">root        21  0.0  0.0  34400  2860 pts/0    R+   07:47   0:00 ps -aux</span><br></pre></td></tr></table></figure></li><li><p>在容器中安装软件包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@363ed45619ae:~# apt-get upate    root@363ed45619ae:~# apt-get install vim</span><br></pre></td></tr></table></figure></li><li><p>退出容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure></li></ul><p>退出后，回到自己的物理机</p><ul><li><p>查看当前系统中的容器列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -a </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">363ed45619ae        ubuntu              &quot;/bin/bash&quot;         19 minutes ago      Exited (0) 31 seconds ago                       keen_boyd</span><br><span class="line">31ef04a4ff1b        hello-world         &quot;/hello&quot;            3 days ago          Exited (0) 3 days ago                           gifted_austin</span><br><span class="line">e4166694ac7c        hello-world         &quot;/hello&quot;            3 days ago          Exited (0) 3 days ago                           brave_kare</span><br></pre></td></tr></table></figure></li><li><p>查看最后一次运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -a -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">363ed45619ae        ubuntu              &quot;/bin/bash&quot;         20 minutes ago      Exited (0) About a minute ago                       keen_boyd</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-容器命名"><a href="#4-容器命名" class="headerlink" title="4.容器命名"></a>4.容器命名</h4><p>–name 标志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name hiekay_container -i -t ubuntu /bin/bash</span><br><span class="line">root@989f63da27d3:/# exit</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">$ sudo docker ps -a -l                                          </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">989f63da27d3        ubuntu              &quot;/bin/bash&quot;         26 seconds ago      Exited (0) 8 seconds ago                       hiekay_container</span><br></pre></td></tr></table></figure></p><p>合法的容器名称符合： [a-zA-Z0-9_·-]</p><h4 id="5-重启停止的容器"><a href="#5-重启停止的容器" class="headerlink" title="5.重启停止的容器"></a>5.重启停止的容器</h4><p>可以通过容器名称 或则 容器ID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker start hiekay_container</span><br><span class="line">hiekay_container</span><br><span class="line"></span><br><span class="line">$ sudo docker start 989f63da27d3                </span><br><span class="line">989f63da27d3</span><br></pre></td></tr></table></figure></p><h4 id="6-附着到容器上"><a href="#6-附着到容器上" class="headerlink" title="6.附着到容器上"></a>6.附着到容器上</h4><p>docker容器重新启动的时候 会重启一个交互式会话shell,我们可以用 docker attach 重新附着到该容器会话上 ， 可通过容器 name 或者 ID 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker attach hiekay_container</span><br><span class="line">root@989f63da27d3:/#</span><br><span class="line"></span><br><span class="line">$ sudo docker attach 989f63da27d3</span><br><span class="line">root@989f63da27d3:/#</span><br></pre></td></tr></table></figure></p><h4 id="7-创建守护式容器"><a href="#7-创建守护式容器" class="headerlink" title="7.创建守护式容器"></a>7.创建守护式容器</h4><p>除了交互式运行的容器，大部分是需要创建长期运行的容器， 守护式容器 没有交互式会话，适合运行应用程序和服务。<br>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name demo -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep1; done&quot; </span><br><span class="line">ea6e0fecba4f5185f62e2a46851882572bdb465fccfdac6b27a64ea9ff3cedc9</span><br></pre></td></tr></table></figure></p><p>其中-d参数 是标志让容器放在后台运行。<br>其中 命令是让 运行一个 while 循环 一直打印 hello world ,直到容器或进程停止。</p><ul><li>可通过 docker ps命令 查看 正在运行的容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps                                                                                   </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">ea6e0fecba4f        ubuntu              &quot;/bin/sh -c &apos;while t…&quot;   2 minutes ago       Up 2 minutes                            demo</span><br></pre></td></tr></table></figure></li></ul><h5 id="8-查看容器内部的工作"><a href="#8-查看容器内部的工作" class="headerlink" title="8.查看容器内部的工作"></a>8.查看容器内部的工作</h5><ul><li>docker logs<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs demo</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ul><p>也可以用 -f参数来监控日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs -f demo</span><br></pre></td></tr></table></figure></p><p>也可以用 tail 命令看最后的几行日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs --tail 10  demo</span><br><span class="line">或</span><br><span class="line">sudo docker logs --tail 0 -f  demo</span><br></pre></td></tr></table></figure></p><h4 id="9-查看容器内的进程"><a href="#9-查看容器内的进程" class="headerlink" title="9.查看容器内的进程"></a>9.查看容器内的进程</h4><ul><li>docker top<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker top demo                                                        </span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                31469               31448               99                  16:11               ?                   00:09:46            /bin/sh -c while true; do echo hello world; sleep1; done</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-在容器内运行进程"><a href="#10-在容器内运行进程" class="headerlink" title="10.在容器内运行进程"></a>10.在容器内运行进程</h4><ul><li>docker exec<br>两种类型：后台任务 和 交互式任务</li><li><p>后台任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker exec -d demo touch /etc/new_file1</span><br></pre></td></tr></table></figure></li><li><p>交互式任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker exec -t -i demo /bin/bash        </span><br><span class="line">root@ea6e0fecba4f:/#</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-停止守护式容器"><a href="#11-停止守护式容器" class="headerlink" title="11.停止守护式容器"></a>11.停止守护式容器</h4><ul><li><p>docker stop name/ID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker stop demo </span><br><span class="line">或</span><br><span class="line">$ sudo docker stop ea6e0fecba4f</span><br></pre></td></tr></table></figure></li><li><p>注意： 也可以通过docker kill 关闭</p><h4 id="12-自动重启容器"><a href="#12-自动重启容器" class="headerlink" title="12.自动重启容器"></a>12.自动重启容器</h4></li><li><p>自动重启标志： –restart </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --restart=always --name demo -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br></pre></td></tr></table></figure></li><li><p>注意： –restart 被设置为 always ，无论退出代码是什么，一直会自动重启。<br>还可以设置为： on-failure 只有当退出代码为0的时候才会自动重启，也可以传参数： 5， 重启次数。<br>–restart=on-failure：5</p><h4 id="13-深入容器"><a href="#13-深入容器" class="headerlink" title="13.深入容器"></a>13.深入容器</h4></li><li><p>docker inspect 获取更多容器信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect demo</span><br><span class="line">//获取的信息</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;ea6e0fecba4f5185f62e2a46851882572bdb465fccfdac6b27a64ea9ff3cedc9&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-10-29T08:11:49.219017867Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true; do echo hello world; sleep1; done&quot;</span><br><span class="line">        ],</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>可以用 -f 或 –format  标志来选定查看结果 ,支持完整的Go语言模板<br>例子：<br>查看容器的运行状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format=&apos;&#123;&#123;.State.Running&#125;&#125;&apos; demo </span><br><span class="line">//返回</span><br><span class="line">false</span><br></pre></td></tr></table></figure></li></ul><p>查看容器IP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; demo</span><br></pre></td></tr></table></figure></p><p>查看多个容器的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect --format=&apos;&#123;&#123;.Name&#125;&#125; &#123;&#123;.State.Running&#125;&#125;&apos; demo demo1</span><br><span class="line">/demo false</span><br><span class="line">/demo1 false</span><br></pre></td></tr></table></figure></p><h4 id="14-删除容器"><a href="#14-删除容器" class="headerlink" title="14.删除容器"></a>14.删除容器</h4><ul><li><p>docker rm name/ID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker rm demo1                                                                                                </span><br><span class="line">demo1</span><br></pre></td></tr></table></figure></li><li><p>注意：删除之前 必须先关闭</p></li><li><p>删除所有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm &apos;docker ps -a -q &apos;</span><br></pre></td></tr></table></figure></li></ul><p>解析：docker -a 列出所有容器，-q 返回ID， 然后传给 sudo rm  ID ， 即可删除。</p><h4 id="15-小结"><a href="#15-小结" class="headerlink" title="15. 小结"></a>15. 小结</h4><p>docker 基础，请多联系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-测试docker是否存在&quot;&gt;&lt;a href=&quot;#1-测试docker是否存在&quot; class=&quot;headerlink&quot; title=&quot;1.测试docker是否存在&quot;&gt;&lt;/a&gt;1.测试docker是否存在&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;sudo docker info
      
    
    </summary>
    
      <category term="docker" scheme="https://hiekay.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://hiekay.github.io/tags/docker/"/>
    
      <category term="Docker入门" scheme="https://hiekay.github.io/tags/Docker%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu18.04安装dockerCE</title>
    <link href="https://hiekay.github.io/2018/11/07/ubuntu18-04%E5%AE%89%E8%A3%85dockerCE/"/>
    <id>https://hiekay.github.io/2018/11/07/ubuntu18-04安装dockerCE/</id>
    <published>2018-11-07T15:18:01.000Z</published>
    <updated>2018-11-07T15:18:36.143Z</updated>
    
    <content type="html"><![CDATA[<p>目前docker分为社区版 docker ce 和 企业版 docker ee。</p><h3 id="卸载老版本"><a href="#卸载老版本" class="headerlink" title="卸载老版本"></a>卸载老版本</h3><p>如果你安装了老版本，请卸载掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="①使用存储库安装"><a href="#①使用存储库安装" class="headerlink" title="①使用存储库安装"></a>①使用存储库安装</h3><p>在新主机上首次安装Docker CE之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker。</p><h4 id="一、设置存储库"><a href="#一、设置存储库" class="headerlink" title="一、设置存储库"></a>一、设置存储库</h4><h5 id="1-更新apt包索引"><a href="#1-更新apt包索引" class="headerlink" title="1.更新apt包索引"></a>1.更新apt包索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><h5 id="2-安装包以允许通过HTTPS使用存储库："><a href="#2-安装包以允许通过HTTPS使用存储库：" class="headerlink" title="2.安装包以允许通过HTTPS使用存储库："></a>2.安装包以允许通过HTTPS使用存储库：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><h5 id="3-添加Docker的官方GPG密钥："><a href="#3-添加Docker的官方GPG密钥：" class="headerlink" title="3.添加Docker的官方GPG密钥："></a>3.添加Docker的官方GPG密钥：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>通过搜索指纹的最后8个字符，确认您现在拥有指纹9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88的密钥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"></span><br><span class="line">pub   4096R/0EBFCD88 2017-02-22</span><br><span class="line">      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   4096R/F273FCD8 2017-02-22</span><br></pre></td></tr></table></figure></p><h5 id="4-使用以下命令设置稳定存储库。即使您还想从边缘或测试存储库安装构建，您始终需要稳定的存储库。要添加边缘或测试存储库，请在以下命令中的单词stable之后添加单词edge或test（或两者）。"><a href="#4-使用以下命令设置稳定存储库。即使您还想从边缘或测试存储库安装构建，您始终需要稳定的存储库。要添加边缘或测试存储库，请在以下命令中的单词stable之后添加单词edge或test（或两者）。" class="headerlink" title="4.使用以下命令设置稳定存储库。即使您还想从边缘或测试存储库安装构建，您始终需要稳定的存储库。要添加边缘或测试存储库，请在以下命令中的单词stable之后添加单词edge或test（或两者）。"></a>4.使用以下命令设置稳定存储库。即使您还想从边缘或测试存储库安装构建，您始终需要稳定的存储库。要添加边缘或测试存储库，请在以下命令中的单词stable之后添加单词edge或test（或两者）。</h5><ul><li><p>注意<br>注意：下面的lsb_release -cs子命令返回Ubuntu发行版的名称，例如xenial。有时，在像Linux Mint这样的发行版中，您可能需要将$（lsb_release -cs）更改为您的父Ubuntu发行版。例如，如果您使用的是Linux Mint Rafaela，则可以使用trusty。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure></li><li><p>注意：从Docker 17.06开始，稳定版本也会被推送到边缘并测试存储库。</p><h4 id="二、安装DOCKER-CE"><a href="#二、安装DOCKER-CE" class="headerlink" title="二、安装DOCKER CE"></a>二、安装DOCKER CE</h4><h5 id="1-更新apt包索引。"><a href="#1-更新apt包索引。" class="headerlink" title="1.更新apt包索引。"></a>1.更新apt包索引。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-安装最新版本的Docker-CE，或转到下一步安装特定版本："><a href="#2-安装最新版本的Docker-CE，或转到下一步安装特定版本：" class="headerlink" title="2.安装最新版本的Docker CE，或转到下一步安装特定版本："></a>2.安装最新版本的Docker CE，或转到下一步安装特定版本：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><h5 id="3-要安装特定版本的Docker-CE，请列出repo中的可用版本，然后选择并安装："><a href="#3-要安装特定版本的Docker-CE，请列出repo中的可用版本，然后选择并安装：" class="headerlink" title="3.要安装特定版本的Docker CE，请列出repo中的可用版本，然后选择并安装："></a>3.要安装特定版本的Docker CE，请列出repo中的可用版本，然后选择并安装：</h5><ul><li><p>列出您的仓库中可用的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">docker-ce | 18.03.0~ce-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages</span><br></pre></td></tr></table></figure></li><li><p>通过其完全限定的包名称安装特定版本，即包名称（docker-ce）“=”版本字符串（第2列），例如，docker-ce = 18.03.0~ce-0~ubuntu。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-查看Docker-CE-版本"><a href="#4-查看Docker-CE-版本" class="headerlink" title="4.查看Docker CE 版本"></a>4.查看Docker CE 版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker -v </span><br><span class="line">Docker version 18.06.1-ce, build e68fc7a</span><br></pre></td></tr></table></figure><h5 id="5-通过运行hello-world映像验证是否正确安装了Docker-CE。"><a href="#5-通过运行hello-world映像验证是否正确安装了Docker-CE。" class="headerlink" title="5.通过运行hello-world映像验证是否正确安装了Docker CE。"></a>5.通过运行hello-world映像验证是否正确安装了Docker CE。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>出现下面这个表示你安装成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure></p><p>Docker CE已安装并正在运行。已创建docker组，但未向其添加任何用户。您需要使用sudo来运行Docker命令。继续Linux postinstall以允许非特权用户运行Docker命令和其他可选配置步骤。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>升级DOCKER CE要升级Docker CE，首先运行sudo apt-get update，然后按照安装说明选择要安装的新版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p><h3 id="②从包安装"><a href="#②从包安装" class="headerlink" title="②从包安装"></a>②从包安装</h3><p>如果您无法使用Docker的存储库来安装Docker CE，则可以下载适用于您的发行版的.deb文件并手动安装。每次要升级Docker CE时都需要下载新文件。</p><h5 id="1-转到https-download-docker-com-linux-ubuntu-dists-，选择您的Ubuntu版本，浏览到pool-stable-并选择amd64，armhf，ppc64el或s390x。下载要安装的Docker版本的-deb文件。"><a href="#1-转到https-download-docker-com-linux-ubuntu-dists-，选择您的Ubuntu版本，浏览到pool-stable-并选择amd64，armhf，ppc64el或s390x。下载要安装的Docker版本的-deb文件。" class="headerlink" title="1.转到https://download.docker.com/linux/ubuntu/dists/，选择您的Ubuntu版本，浏览到pool / stable /并选择amd64，armhf，ppc64el或s390x。下载要安装的Docker版本的.deb文件。"></a>1.转到<a href="https://download.docker.com/linux/ubuntu/dists/，选择您的Ubuntu版本，浏览到pool" target="_blank" rel="noopener">https://download.docker.com/linux/ubuntu/dists/，选择您的Ubuntu版本，浏览到pool</a> / stable /并选择amd64，armhf，ppc64el或s390x。下载要安装的Docker版本的.deb文件。</h5><p>要安装edge包，请将URL中的单词stable更改为edge。 </p><h5 id="2-安装Docker-CE，将下面的路径更改为您下载Docker软件包的路径。"><a href="#2-安装Docker-CE，将下面的路径更改为您下载Docker软件包的路径。" class="headerlink" title="2.安装Docker CE，将下面的路径更改为您下载Docker软件包的路径。"></a>2.安装Docker CE，将下面的路径更改为您下载Docker软件包的路径。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -i /path/to/package.deb</span><br></pre></td></tr></table></figure><p>Docker守护程序自动启动。</p><h5 id="3-通过运行hello-world映像验证是否正确安装了Docker-CE。"><a href="#3-通过运行hello-world映像验证是否正确安装了Docker-CE。" class="headerlink" title="3.通过运行hello-world映像验证是否正确安装了Docker CE。"></a>3.通过运行hello-world映像验证是否正确安装了Docker CE。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><h4 id="升级DOCKER-CE"><a href="#升级DOCKER-CE" class="headerlink" title="升级DOCKER CE"></a>升级DOCKER CE</h4><p>要升级Docker CE，请下载较新的软件包文件并重复安装过程，指向新文件。</p><h3 id="③使用便利脚本安装"><a href="#③使用便利脚本安装" class="headerlink" title="③使用便利脚本安装"></a>③使用便利脚本安装</h3><p>Docker在get.docker.com和test.docker.com上提供了便捷脚本，用于快速，非交互地将Docker CE的边缘和测试版本安装到开发环境中。脚本的源代码位于docker-install存储库中。建议不要在生产环境中使用这些脚本，并且在使用它们之前应该了解潜在的风险：</p><ul><li>脚本需要root或sudo权限才能运行。因此，在运行脚本之前，应仔细检查和审核脚本。</li><li>这些脚本会尝试检测您的Linux发行版和版本，并为您配置包管理系统。此外，脚本不允许您自定义任何安装参数。</li><li>从Docker的角度或您自己组织的指导方针和标准来看，这可能会导致配置不受支持。脚本安装包管理器的所有依赖项和建议，而不要求确认。</li><li>这可能会安装大量软件包，具体取决于主机的当前配置。该脚本不提供选项来指定要安装的Docker版本，并安装在“边缘”通道中发布的最新版本。</li><li>如果已使用其他机制在主机上安装了Docker，请不要使用便捷脚本。</li></ul><p>此示例使用get.docker.com上的脚本在Linux上安装最新版本的Docker CE。要安装最新的测试版本，请改用test.docker.com。在下面的每个命令中，将每次出现的get替换为test。</p><h5 id="1-始终检查从Internet下载的脚本，然后在本地运行它们。"><a href="#1-始终检查从Internet下载的脚本，然后在本地运行它们。" class="headerlink" title="1.始终检查从Internet下载的脚本，然后在本地运行它们。"></a>1.始终检查从Internet下载的脚本，然后在本地运行它们。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh</span><br><span class="line"></span><br><span class="line">&lt;output truncated&gt;</span><br></pre></td></tr></table></figure><p>如果您想将Docker用作非root用户，您现在应该考虑将您的用户添加到“docker”组，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker your-user</span><br></pre></td></tr></table></figure></p><p>请记得注销并重新登录才能生效！<br>将用户添加到“docker”组可以运行容器，该容器可用于获取docker主机上的root权限。<br>已安装Docker CE。它在基于DEB的发行版上自动启动。在基于RPM的发行版上，您需要使用适当的systemctl或service命令手动启动它。如消息所示，非root用户默认情况下无法运行Docker命令。<br>如果您使用便捷脚本安装了Docker，则应直接使用软件包管理器升级Docker。重新运行便捷脚本没有任何好处，如果它尝试重新添加已添加到主机的存储库，则可能会导致问题。</p><h2 id="卸载Docker-CE"><a href="#卸载Docker-CE" class="headerlink" title="卸载Docker CE"></a>卸载Docker CE</h2><h5 id="1-卸载Docker-CE软件包："><a href="#1-卸载Docker-CE软件包：" class="headerlink" title="1.卸载Docker CE软件包："></a>1.卸载Docker CE软件包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure><h5 id="2-主机上的图像，容器，卷或自定义配置文件不会自动删除。要删除所有图像，容器和卷："><a href="#2-主机上的图像，容器，卷或自定义配置文件不会自动删除。要删除所有图像，容器和卷：" class="headerlink" title="2.主机上的图像，容器，卷或自定义配置文件不会自动删除。要删除所有图像，容器和卷："></a>2.主机上的图像，容器，卷或自定义配置文件不会自动删除。要删除所有图像，容器和卷：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf / var / lib / docker</span><br></pre></td></tr></table></figure><p>您必须手动删除任何已编辑的配置文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前docker分为社区版 docker ce 和 企业版 docker ee。&lt;/p&gt;
&lt;h3 id=&quot;卸载老版本&quot;&gt;&lt;a href=&quot;#卸载老版本&quot; class=&quot;headerlink&quot; title=&quot;卸载老版本&quot;&gt;&lt;/a&gt;卸载老版本&lt;/h3&gt;&lt;p&gt;如果你安装了老版本，
      
    
    </summary>
    
      <category term="docker" scheme="https://hiekay.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://hiekay.github.io/tags/docker/"/>
    
      <category term="dockerCE" scheme="https://hiekay.github.io/tags/dockerCE/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04安装sublime3</title>
    <link href="https://hiekay.github.io/2018/11/07/Ubuntu18-04%E5%AE%89%E8%A3%85sublime3/"/>
    <id>https://hiekay.github.io/2018/11/07/Ubuntu18-04安装sublime3/</id>
    <published>2018-11-07T15:13:32.000Z</published>
    <updated>2018-11-07T15:15:30.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装-GPG-key"><a href="#1-安装-GPG-key" class="headerlink" title="1.安装 GPG key:"></a>1.安装 GPG key:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><h3 id="2-确保apt已设置为使用https源"><a href="#2-确保apt已设置为使用https源" class="headerlink" title="2.  确保apt已设置为使用https源"></a>2.  确保apt已设置为使用https源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https</span><br></pre></td></tr></table></figure><h3 id="3-输出list"><a href="#3-输出list" class="headerlink" title="3.输出list"></a>3.输出list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.list</span><br></pre></td></tr></table></figure><h3 id="4-更新apt源并安装Sublime-Text"><a href="#4-更新apt源并安装Sublime-Text" class="headerlink" title="4.更新apt源并安装Sublime Text"></a>4.更新apt源并安装Sublime Text</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text</span><br></pre></td></tr></table></figure><h3 id="5-注册"><a href="#5-注册" class="headerlink" title="5.注册"></a>5.注册</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    1.打开工具</span><br><span class="line"></span><br><span class="line">    2.点击Help选项下的Enter License，将下面Register码复制粘贴</span><br><span class="line"></span><br><span class="line">    3.点击提交，即可！</span><br><span class="line"></span><br><span class="line">----- BEGIN LICENSE -----</span><br><span class="line">sgbteam</span><br><span class="line">Single User License</span><br><span class="line">EA7E-1153259</span><br><span class="line">8891CBB9 F1513E4F 1A3405C1 A865D53F</span><br><span class="line">115F202E 7B91AB2D 0D2A40ED 352B269B</span><br><span class="line">76E84F0B CD69BFC7 59F2DFEF E267328F</span><br><span class="line">215652A3 E88F9D8F 4C38E3BA 5B2DAAE4</span><br><span class="line">969624E7 DC9CD4D5 717FB40C 1B9738CF</span><br><span class="line">20B3C4F1 E917B5B3 87C38D9C ACCE7DD8</span><br><span class="line">5F7EF854 86B9743C FADC04AA FB0DA5C0</span><br><span class="line">F913BE58 42FEA319 F954EFDD AE881E0B</span><br><span class="line">------ END LICENSE ------</span><br></pre></td></tr></table></figure><h3 id="6-支持中文"><a href="#6-支持中文" class="headerlink" title="6.支持中文"></a>6.支持中文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.git clone https://github.com/lyfeyaj/sublime-text-imfix.git</span><br><span class="line"></span><br><span class="line">2.cd sublime-text-imfix &amp;&amp; ./sublime-imfix</span><br></pre></td></tr></table></figure><h3 id="7-重启Sublime-Text3即可！-快捷命令-subl"><a href="#7-重启Sublime-Text3即可！-快捷命令-subl" class="headerlink" title="7.重启Sublime Text3即可！  快捷命令: subl"></a>7.重启Sublime Text3即可！  快捷命令: subl</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装-GPG-key&quot;&gt;&lt;a href=&quot;#1-安装-GPG-key&quot; class=&quot;headerlink&quot; title=&quot;1.安装 GPG key:&quot;&gt;&lt;/a&gt;1.安装 GPG key:&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
      <category term="tools" scheme="https://hiekay.github.io/categories/tools/"/>
    
    
      <category term="sublime3" scheme="https://hiekay.github.io/tags/sublime3/"/>
    
      <category term="linux 小工具" scheme="https://hiekay.github.io/tags/linux-%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>gitstash使用教程</title>
    <link href="https://hiekay.github.io/2018/10/22/gitstash%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://hiekay.github.io/2018/10/22/gitstash使用教程/</id>
    <published>2018-10-21T17:27:13.000Z</published>
    <updated>2018-10-21T17:27:41.456Z</updated>
    
    <content type="html"><![CDATA[<p>git stash用于将当前工作区的修改暂存起来，就像堆栈一样，可以随时将某一次缓存的修改再重新应用到当前工作区。一旦用好了这个命令，会极大提高工作效率。<br>举例说明:</p><h3 id="1、准备工作，首先初始化一个git仓"><a href="#1、准备工作，首先初始化一个git仓" class="headerlink" title="1、准备工作，首先初始化一个git仓"></a>1、准备工作，首先初始化一个git仓</h3><pre><code>随便建立一个目录，进去，然后使用 ：$: git init .添加一个文件：$: touch hello$: git add .$: git commit -m &quot;first add&quot;</code></pre><h3 id="2、暂存当前修改内容（git-stash）"><a href="#2、暂存当前修改内容（git-stash）" class="headerlink" title="2、暂存当前修改内容（git stash）"></a>2、暂存当前修改内容（git stash）</h3><pre><code>假设我们在写一个C函数，如下：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$:~/code/linux/git$ vim hello.c </span><br><span class="line">$:~/code/linux/git$ git diff</span><br><span class="line">diff --git a/hello.c b/hello.c</span><br><span class="line">index e69de29..bdc92a5 100644</span><br><span class="line">--- a/hello.c</span><br><span class="line">+++ b/hello.c</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+void func1(void) &#123;printf(&quot;this is func1&quot;);&#125;</span><br><span class="line">+void main(void) &#123;return func1();&#125;</span><br></pre></td></tr></table></figure><p>调试OK，发现func1功能OK，但是应该优化一下，可能效率更高，这个时候怎么办？<br> 直接改func1的话，如果发现修改不合适，想回退的话很麻烦，这个时候可以用git stash将将修改暂存起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$: ~/code/linux/git$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: 452b08d rename hello as hello.c</span><br><span class="line">HEAD is now at 452b08d rename hello as hello.c</span><br><span class="line">$:~/code/linux/git$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure></p><h3 id="3、弹出修改内容（git-stash-pop）"><a href="#3、弹出修改内容（git-stash-pop）" class="headerlink" title="3、弹出修改内容（git stash pop）"></a>3、弹出修改内容（git stash pop）</h3><p> 　这个时候你重新编写func1， 发现效果不好，后悔了，于是可以用git stash pop命令，弹出刚才的内容(注意先用git checkout . 清空工作区)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$:~/code/linux/git$ vim hello.c </span><br><span class="line">$:~/code/linux/git$ git diff</span><br><span class="line">diff --git a/hello.c b/hello.c</span><br><span class="line">index e69de29..9c5bff3 100644</span><br><span class="line">--- a/hello.c</span><br><span class="line">+++ b/hello.c</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+some bad chenges....</span><br><span class="line">$:~/code/linux/git$ git checkout .</span><br><span class="line">$:~/code/linux/git$ git stash pop</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   hello.c</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (208ca2e2c0c455da554986a6770a74ad0de5b1e0)</span><br><span class="line">$:~/code/linux/git$ git diff</span><br><span class="line">diff --git a/hello.c b/hello.c</span><br><span class="line">index e69de29..bdc92a5 100644</span><br><span class="line">--- a/hello.c</span><br><span class="line">+++ b/hello.c</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+void func1(void) &#123;printf(&quot;this is func1&quot;);&#125;</span><br><span class="line">+void main(void) &#123;return func1();&#125;</span><br></pre></td></tr></table></figure></p><p>注意，git stash pop 弹出成功后，暂存列表里面就没有了，如果当前工作区不干净，弹出时有冲突，则暂存列表会继续保留修改。</p><h3 id="4、可以保存多个修改"><a href="#4、可以保存多个修改" class="headerlink" title="4、可以保存多个修改"></a>4、可以保存多个修改</h3><p>  假设你在实现一个功能，有好几种算法可以实现，你想逐个尝试看效果。<br>  现在你在func1中实现了一种方法，准备尝试写func2，用另一种方法。<br>  那么可以将func1的修改入栈，去写fun2，等fun2写好后，你又想试试func3，那么没关系，可以用同样的方法保存func2的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$:~/code/linux/git$ git diff</span><br><span class="line">diff --git a/hello.c b/hello.c</span><br><span class="line">index e69de29..bdc92a5 100644</span><br><span class="line">--- a/hello.c</span><br><span class="line">+++ b/hello.c</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+void func1(void) &#123;printf(&quot;this is func1&quot;);&#125;</span><br><span class="line">+void main(void) &#123;return func1();&#125;</span><br><span class="line">$:~/code/linux/git$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: 452b08d rename hello as hello.c</span><br><span class="line">HEAD is now at 452b08d rename hello as hello.c</span><br><span class="line">$:~/code/linux/git$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">$:~/code/linux/git$ vim hello.c </span><br><span class="line">$:~/code/linux/git$ git diff</span><br><span class="line">diff --git a/hello.c b/hello.c</span><br><span class="line">index e69de29..7fd0a13 100644</span><br><span class="line">--- a/hello.c</span><br><span class="line">+++ b/hello.c</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+void func2(void) &#123;printf(&quot;this is func2&quot;);&#125;</span><br><span class="line">+void main(void) &#123;return func2();&#125;</span><br><span class="line">$:~/code/linux/git$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: 452b08d rename hello as hello.c</span><br><span class="line">HEAD is now at 452b08d rename hello as hello.c</span><br><span class="line">$:~/code/linux/git$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><h3 id="5、查看保存的内容列表（git-stash-list）"><a href="#5、查看保存的内容列表（git-stash-list）" class="headerlink" title="5、查看保存的内容列表（git stash list）"></a>5、查看保存的内容列表（git stash list）</h3><p>  现在我们保存了两个修改，一个func1，一个func2，可以通过git stash list去查看保存内容列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$:~/code/linux/git$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 452b08d rename hello as hello.c</span><br><span class="line">stash@&#123;1&#125;: WIP on master: 452b08d rename hello as hello.c</span><br></pre></td></tr></table></figure></p><p>可以清楚的看到这两次修改，stash@{0}和stash@{1}， 那么哪个对应func1，哪个对应func2的修改呢？<br>  这时我们需要使用git stash show stash@{X}命令来查看，其中‘X’表示列表号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$:~/code/linux/git$ git show stash@&#123;0&#125;</span><br><span class="line">commit 72e6a391bcad186ab24676aa1db8d5831c99cec9</span><br><span class="line">Merge: 452b08d 6c95c30</span><br><span class="line">Author: hiekay</span><br><span class="line">Date:   Sat Mar 12 19:56:18 2016 +0800</span><br><span class="line"></span><br><span class="line">    WIP on master: 452b08d rename hello as hello.c</span><br><span class="line"></span><br><span class="line">diff --cc hello.c</span><br><span class="line">index e69de29,e69de29..7fd0a13</span><br><span class="line">--- a/hello.c</span><br><span class="line">+++ b/hello.c</span><br><span class="line">@@@ -1,0 -1,0 +1,2 @@@</span><br><span class="line">++void func2(void) &#123;printf(&quot;this is func2&quot;);&#125;</span><br><span class="line">++void main(void) &#123;return func2();&#125;</span><br><span class="line">$:~/code/linux/git$ git show stash@&#123;1&#125;</span><br><span class="line">commit 7fcca4b66640c51ca76e637df03264b7c41885be</span><br><span class="line">Merge: 452b08d 1c37881</span><br><span class="line">Author: hiekay</span><br><span class="line">Date:   Sat Mar 12 19:54:35 2016 +0800</span><br><span class="line"></span><br><span class="line">    WIP on master: 452b08d rename hello as hello.c</span><br><span class="line"></span><br><span class="line">diff --cc hello.c</span><br><span class="line">index e69de29,e69de29..bdc92a5</span><br><span class="line">--- a/hello.c</span><br><span class="line">+++ b/hello.c</span><br><span class="line">@@@ -1,0 -1,0 +1,2 @@@</span><br><span class="line">++void func1(void) &#123;printf(&quot;this is func1&quot;);&#125;</span><br><span class="line">++void main(void) &#123;return func1();&#125;</span><br></pre></td></tr></table></figure></p><p> 发现stash@{0}对应func2的修改， stash@{1}对应func1的修改，原来新入栈的修改，其代号为0，循环命名。</p><h3 id="6、应用任意一次修改到当前目录-git-apply-stash-x"><a href="#6、应用任意一次修改到当前目录-git-apply-stash-x" class="headerlink" title="6、应用任意一次修改到当前目录(git apply stash@{x})"></a>6、应用任意一次修改到当前目录(git apply stash@{x})</h3><p> 如果现在又想回到func1的修改，怎么办呢？在工作区干净的情况下，要使用git stash apply stash@{1}。<br> 注意这时不能使用git stash pop， 它将最栈顶，即stash@{0}的修改弹出来，而func1现在已经是stash@{1}了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$:~/code/linux/git$ git stash apply stash@&#123;1&#125;</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   hello.c</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">$:~/code/linux/git$ git diff</span><br><span class="line">diff --git a/hello.c b/hello.c</span><br><span class="line">index e69de29..bdc92a5 100644</span><br><span class="line">--- a/hello.c</span><br><span class="line">+++ b/hello.c</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+void func1(void) &#123;printf(&quot;this is func1&quot;);&#125;</span><br><span class="line">+void main(void) &#123;return func1();&#125;</span><br></pre></td></tr></table></figure></p><p>可见git stash apply可以将列表中任何一次修改应用到当前工作区，我们再次git stash list一把：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$:~/code/linux/git$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 452b08d rename hello as hello.c</span><br><span class="line">stash@&#123;1&#125;: WIP on master: 452b08d rename hello as hello.c</span><br></pre></td></tr></table></figure></p><p>我们发现，虽然func1的修改已经被弹出应用到当前工作区，其修改内容还继续保留在暂存列表，并未丢弃。<br>  当然，我们可以使用git stash drop stash@{1}来丢掉stash@{1}</p><h3 id="7、保存时打标记（git-stash-save）"><a href="#7、保存时打标记（git-stash-save）" class="headerlink" title="7、保存时打标记（git stash save）"></a>7、保存时打标记（git stash save）</h3><p>  假设现在我们又开始尝试写func3， 这样越来越多，这样列表会越来越大，你要想搞清楚某次修改对应哪个函数，就要挨个用git stash show看一遍，很麻烦。<br>  那么，这个时候git stash 的save参数就有用了，它可以为这次暂存做个标记，使得你用git stash list的时候显示这些标记，方便你回忆是修改的什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$:~/code/linux/git$ vim hello.c </span><br><span class="line">$:~/code/linux/git$ git diff</span><br><span class="line">diff --git a/hello.c b/hello.c</span><br><span class="line">index e69de29..786c214 100644</span><br><span class="line">--- a/hello.c</span><br><span class="line">+++ b/hello.c</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+void func3(void) &#123;printf(&quot;this is func3&quot;);&#125;</span><br><span class="line">+void main(void) &#123;return func3();&#125;</span><br><span class="line">$:~/code/linux/git$ git stash save &quot;this is func3&quot;</span><br><span class="line">Saved working directory and index state On master: this is func3</span><br><span class="line">HEAD is now at 452b08d rename hello as hello.c</span><br><span class="line">$:~/code/linux/git$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On master: this is func3</span><br><span class="line">stash@&#123;1&#125;: WIP on master: 452b08d rename hello as hello.c</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 452b08d rename hello as hello.c</span><br></pre></td></tr></table></figure></p><p>我们在save后面指定一个字符串，作为提醒，这样在git stash list查看时就能知道每一个代号对应的修改了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git stash用于将当前工作区的修改暂存起来，就像堆栈一样，可以随时将某一次缓存的修改再重新应用到当前工作区。一旦用好了这个命令，会极大提高工作效率。&lt;br&gt;举例说明:&lt;/p&gt;
&lt;h3 id=&quot;1、准备工作，首先初始化一个git仓&quot;&gt;&lt;a href=&quot;#1、准备工作，首
      
    
    </summary>
    
      <category term="git" scheme="https://hiekay.github.io/categories/git/"/>
    
    
      <category term="stash" scheme="https://hiekay.github.io/tags/stash/"/>
    
      <category term="git" scheme="https://hiekay.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu-linux-安装配置shadowsocks-qt5客户端</title>
    <link href="https://hiekay.github.io/2018/10/22/ubuntu-linux-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEshadowsocks-qt5%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>https://hiekay.github.io/2018/10/22/ubuntu-linux-安装配置shadowsocks-qt5客户端/</id>
    <published>2018-10-21T17:24:02.000Z</published>
    <updated>2018-10-21T17:29:29.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、添加源"><a href="#1、添加源" class="headerlink" title="1、添加源"></a>1、添加源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br></pre></td></tr></table></figure><h3 id="2、更新源"><a href="#2、更新源" class="headerlink" title="2、更新源"></a>2、更新源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure><h3 id="4、启动、配置"><a href="#4、启动、配置" class="headerlink" title="4、启动、配置"></a>4、启动、配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-qt5</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5110710-057b32f7a0ec3155.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="5、chrom浏览器-安装-SwitchyOmega"><a href="#5、chrom浏览器-安装-SwitchyOmega" class="headerlink" title="5、chrom浏览器 安装 SwitchyOmega"></a>5、chrom浏览器 安装 SwitchyOmega</h3><p><a href="https://github.com/FelisCatus/SwitchyOmega/releases" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、添加源&quot;&gt;&lt;a href=&quot;#1、添加源&quot; class=&quot;headerlink&quot; title=&quot;1、添加源&quot;&gt;&lt;/a&gt;1、添加源&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://hiekay.github.io/categories/ubuntu/"/>
    
    
      <category term="shadowsocks-qt5" scheme="https://hiekay.github.io/tags/shadowsocks-qt5/"/>
    
      <category term="ubuntu" scheme="https://hiekay.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu系统中给应用创建快捷方式</title>
    <link href="https://hiekay.github.io/2018/10/22/%E5%9C%A8Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%BB%99%E5%BA%94%E7%94%A8%E5%88%9B%E5%BB%BA%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <id>https://hiekay.github.io/2018/10/22/在Ubuntu系统中给应用创建快捷方式/</id>
    <published>2018-10-21T17:22:37.000Z</published>
    <updated>2018-10-21T17:23:34.471Z</updated>
    
    <content type="html"><![CDATA[<p>背景：因为Ubuntu中没有QQ版本可以使用，所以用wine+QQ 。之后安装完之后，肯定需要创建一个类似于window系统中的桌面快捷启动。每次都在终端中启动QQ实在太麻烦了, 所以我决定给QQ添加一个桌面启动器, 就是就是windows下面的快捷方式。<br>Ubuntu下dash home中每个图标对应<strong>/usr/share/applications</strong>当中的一个配置文件(文件后缀为.desktop), 所以要在dash home中 添加一个自定义程序启动器, 需要在该文件目录下创建对应的配置文件</p><h3 id="1、下载图标"><a href="#1、下载图标" class="headerlink" title="1、下载图标"></a>1、下载图标</h3><p>下载保存到  /home/hiekay/qq </p><h3 id="2、-创建qq-desktop"><a href="#2、-创建qq-desktop" class="headerlink" title="2、 创建qq.desktop"></a>2、 创建qq.desktop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/applicat</span><br><span class="line">sudo  vim qq.desktop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=Electronic Wechat</span><br><span class="line">Name[zh_CN]=QQ</span><br><span class="line">Name[zh_TW]=QQ</span><br><span class="line">Exec=wine /home/hiekay/.wine/drive_c/Program\ Files\ \(x86\)//Tencent/QQ/Bin/QQ.exe</span><br><span class="line">Icon=/home/hiekay/qq/qqicon.png</span><br><span class="line">Terminal=false</span><br><span class="line">X-MultipleArgs=false</span><br><span class="line">Type=Application</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Application;Utility;Network;InstantMessaging;</span><br><span class="line">StartupNotify=false</span><br></pre></td></tr></table></figure><p>解释：<br>示例中的QQ应用程序包放在了/opt/electronic-wechat目录下, 而启动器对应/usr/share/applications, 这是全局有效的, 而如果我们只是期望对本用户有效, 可以讲应用程序包放在自己的$HOME(~)下面, 而启动器则放到~/.local/share/applications目录下</p><h3 id="3、授权"><a href="#3、授权" class="headerlink" title="3、授权"></a>3、授权</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 qq.desktop</span><br></pre></td></tr></table></figure><p>或者 创建 .sh 启动</p><h3 id="qq-sh"><a href="#qq-sh" class="headerlink" title="qq.sh"></a>qq.sh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">cd /home/hiekay/.wine/drive_c/Program\ Files\ \(x86\)//Tencent/QQ/Bin</span><br><span class="line">WINEDEBUG=-all wine ./QQ.exe</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;背景：因为Ubuntu中没有QQ版本可以使用，所以用wine+QQ 。之后安装完之后，肯定需要创建一个类似于window系统中的桌面快捷启动。每次都在终端中启动QQ实在太麻烦了, 所以我决定给QQ添加一个桌面启动器, 就是就是windows下面的快捷方式。&lt;br&gt;Ubunt
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://hiekay.github.io/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="https://hiekay.github.io/tags/ubuntu/"/>
    
      <category term="快捷方式" scheme="https://hiekay.github.io/tags/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu-inux设置开机启动软件</title>
    <link href="https://hiekay.github.io/2018/10/22/ubuntu-inux%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%BD%AF%E4%BB%B6/"/>
    <id>https://hiekay.github.io/2018/10/22/ubuntu-inux设置开机启动软件/</id>
    <published>2018-10-21T17:20:27.000Z</published>
    <updated>2018-10-21T17:22:19.725Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、终端输入：-gnome-session-properties"><a href="#1、终端输入：-gnome-session-properties" class="headerlink" title="1、终端输入： gnome-session-properties"></a>1、终端输入： gnome-session-properties</h5><h5 id="2、弹出窗口为“-启动应用程序首选项”"><a href="#2、弹出窗口为“-启动应用程序首选项”" class="headerlink" title="2、弹出窗口为“ 启动应用程序首选项”"></a>2、弹出窗口为“ 启动应用程序首选项”</h5><h5 id="3、点击右侧添加"><a href="#3、点击右侧添加" class="headerlink" title="3、点击右侧添加"></a>3、点击右侧添加</h5><h5 id="4、-输入描述和软件路径"><a href="#4、-输入描述和软件路径" class="headerlink" title="4、 输入描述和软件路径"></a>4、 输入描述和软件路径</h5><h5 id="5、这里的软件路径在-usr-bin目录下，所以最终的命令栏输入的内容是：-usr-bin-albert-（以添加albert开机启动为例）"><a href="#5、这里的软件路径在-usr-bin目录下，所以最终的命令栏输入的内容是：-usr-bin-albert-（以添加albert开机启动为例）" class="headerlink" title="5、这里的软件路径在 /usr/bin目录下，所以最终的命令栏输入的内容是：/usr/bin/albert  （以添加albert开机启动为例）"></a>5、这里的软件路径在 /usr/bin目录下，所以最终的命令栏输入的内容是：/usr/bin/albert  （以添加albert开机启动为例）</h5><p>各步骤截图如下：<br><img src="https://upload-images.jianshu.io/upload_images/5110710-d069e3f937a900e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/5110710-486ac8c03c467c81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1、终端输入：-gnome-session-properties&quot;&gt;&lt;a href=&quot;#1、终端输入：-gnome-session-properties&quot; class=&quot;headerlink&quot; title=&quot;1、终端输入： gnome-session-proper
      
    
    </summary>
    
      <category term="ubuntu" scheme="https://hiekay.github.io/categories/ubuntu/"/>
    
    
      <category term="ubuntu" scheme="https://hiekay.github.io/tags/ubuntu/"/>
    
      <category term="开机启动" scheme="https://hiekay.github.io/tags/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>intellij-idea推荐安装有用插件</title>
    <link href="https://hiekay.github.io/2018/10/19/intellij-idea%E6%8E%A8%E8%8D%90%E5%AE%89%E8%A3%85%E6%9C%89%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://hiekay.github.io/2018/10/19/intellij-idea推荐安装有用插件/</id>
    <published>2018-10-19T14:49:22.000Z</published>
    <updated>2018-10-19T14:49:54.013Z</updated>
    
    <content type="html"><![CDATA[<p>打开 intellj idea  插件 搜索安装即可。</p><ul><li><ol><li>activate-power-mode 装逼必备<br><a href="https://github.com/ViceFantasyPlace/activate-power-mode" target="_blank" rel="noopener">activate-power-mode</a></li></ol></li><li><ol start="2"><li>IdeaVim  一个Vim仿真插件</li></ol></li><li><ol start="3"><li>CodeGlance 类似SublimeText的Mini Map插件<br> <a href="https://plugins.jetbrains.com/plugin/7275-codeglance" target="_blank" rel="noopener">CodeGlance</a></li></ol></li><li><ol start="4"><li>Background Image Plus<br>这又是一款装备B插件了，想想别人看到你的IDE有个美女或者异次元背景是怎样的，安装之后，在打开View选项，就可以看到Set Background Image选项了。 </li></ol></li><li><ol start="5"><li>Shifter<br>检测光标所在选中、行或关键字的类型，然后用键盘快捷键上的“up”或“down”键移动它。如果在一行中只有一个可移动的单词，那么它不需要碰触光标，我们就可以移动它。支持小写/大写或小写所移动单词中的第一个大写的字符。<br>默认键盘快捷键：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + Alt+逗号：下移</span><br><span class="line">Ctrl + Shift + Alt +句号：上移</span><br><span class="line">Ctrl + Shift + Alt + K：上移更多</span><br><span class="line">Ctrl + Shift + Alt + J：下移更多</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>移动更多：多次重复选择所选中的值。重复次数可在插件配置中进行配置（默认为10）。</p><ul><li><ol start="6"><li>BrowseWordAtCaret<br>允许轻松地在光标处浏览下一个/前一个单词，并突出选中单词的其他表象。用法：用CTRL-ALT-UP、CTRL-ALT-DOWN浏览（注：在默认键映射中此快捷方式也可用于下一个/上一个事件）。</li></ol></li><li><ol start="7"><li>AceJump<br>AceJump其实是一款能够代替鼠标的软件，只要安装了这款插件，可以在代码中跳转到任意位置。按快捷键进入 AceJump 模式后（默认是 Ctrl+J），再按任一个字符，插件就会在屏幕中这个字符的所有出现位置都打上标签，你只要再按一下标签的字符，就能把光标移到该位置上。换言之，你要移动光标时，眼睛一直看着目标位置就行了，根本不用管光标的当前位置。</li></ol></li><li><ol start="8"><li>Markdown support<br>安装这个插件之后，打开.md文件就可以通过一个支持md的视图查看和编辑内容。一般用于写README.md文件。 </li></ol></li><li><ol start="9"><li>Key promoter<br>Key promoter这款插件适合新手使用。当你点击鼠标一个功能的时候，可以提示你这个功能快捷键是什么。这是一个非常有用的功能，很快就可以熟悉软件的快捷功能了。<br>如果有快捷键的，会直接显示快捷键 </li></ol></li><li><ol start="10"><li>Maven Helper （MAVEN 插件 超好用）</li></ol></li><li><ol start="11"><li>GsonFormat （json转实体）</li></ol></li><li><ol start="12"><li>Jrebel （热部署，可能会收费，自行查找破解）</li></ol></li><li><ol start="13"><li>markdown （一般用于写README.md文件）</li></ol></li><li><ol start="14"><li>Key promoter （适合新手，点击一个功能后会提示这个功能的快捷键）</li></ol></li><li><ol start="15"><li>Grep Console （控制台输出变色）</li></ol></li><li><ol start="16"><li>String Manipulation （字符串快速格式转换）</li></ol></li><li><ol start="17"><li>GenerateToString （重写toString 方法）</li></ol></li><li><ol start="18"><li>Translation （翻译插件） <h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2></li></ol></li></ul><table><thead><tr><th>插件名称</th><th>插件介绍</th><th>官网地址</th></tr></thead><tbody><tr><td>Gitee</td><td>开源中国的码云插件</td><td><a href="https://plugins.jetbrains.com/plugin/8383-gitee" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8383-gitee</a></td></tr><tr><td>Alibaba Java Coding Guidelines</td><td>阿里巴巴出的代码规范检查插件</td><td><a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines</a></td></tr><tr><td>IDE Features Trainer</td><td>IntelliJ IDEA 官方出的学习辅助插件</td><td><a href="https://plugins.jetbrains.com/plugin/8554?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8554?pr=idea</a></td></tr><tr><td>Key promoter</td><td>快捷键提示</td><td><a href="https://plugins.jetbrains.com/plugin/4455?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/4455?pr=idea</a></td></tr><tr><td>Grep Console</td><td>自定义设置控制台输出颜色</td><td><a href="https://plugins.jetbrains.com/idea/plugin/7125-grep-console" target="_blank" rel="noopener">https://plugins.jetbrains.com/idea/plugin/7125-grep-console</a></td></tr><tr><td>String Manipulation</td><td>驼峰式命名和下划线命名交替变化</td><td><a href="https://plugins.jetbrains.com/plugin/2162?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/2162?pr=idea</a></td></tr><tr><td>CheckStyle-IDEA</td><td>代码规范检查</td><td><a href="https://plugins.jetbrains.com/plugin/1065?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/1065?pr=idea</a></td></tr><tr><td>FindBugs-IDEA</td><td>潜在 Bug 检查</td><td><a href="https://plugins.jetbrains.com/plugin/3847?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/3847?pr=idea</a></td></tr><tr><td>MetricsReloaded</td><td>代码复杂度检查</td><td><a href="https://plugins.jetbrains.com/plugin/93?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/93?pr=idea</a></td></tr><tr><td>Statistic</td><td>代码统计</td><td><a href="https://plugins.jetbrains.com/plugin/4509?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/4509?pr=idea</a></td></tr><tr><td>JRebel Plugin</td><td>热部署</td><td><a href="https://plugins.jetbrains.com/plugin/?id=4441" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/?id=4441</a></td></tr><tr><td>CodeGlance</td><td>在编辑代码最右侧，显示一块代码小地图</td><td><a href="https://plugins.jetbrains.com/plugin/7275?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7275?pr=idea</a></td></tr><tr><td>GsonFormat</td><td>把 JSON 字符串直接实例化成类</td><td><a href="https://plugins.jetbrains.com/plugin/7654?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7654?pr=idea</a></td></tr><tr><td>Markdown Navigator</td><td>书写 Markdown 文章</td><td><a href="https://plugins.jetbrains.com/plugin/7896?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7896?pr=idea</a></td></tr><tr><td>Eclipse Code Formatter</td><td>使用 Eclipse 的代码格式化风格，在一个团队中如果公司有规定格式化风格，这个可以使用。</td><td><a href="https://plugins.jetbrains.com/plugin/6546?pr=idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/6546?pr=idea</a></td></tr><tr><td>Jindent-Source Code Formatter</td><td>自定义类、方法、doc、变量注释模板</td><td><a href="http://plugins.jetbrains.com/plugin/2170?pr=idea" target="_blank" rel="noopener">http://plugins.jetbrains.com/plugin/2170?pr=idea</a></td></tr><tr><td>Translation</td><td>翻译插件</td><td><a href="https://github.com/YiiGuxing/TranslationPlugin" target="_blank" rel="noopener">https://github.com/YiiGuxing/TranslationPlugin</a></td></tr><tr><td>Maven Helper</td><td>Maven 辅助插件</td><td><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7179-maven-helper</a></td></tr><tr><td>Properties to YAML Converter</td><td>把 Properties 的配置格式改为 YAML 格式</td><td><a href="https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter</a></td></tr><tr><td>Git Flow Integration</td><td>Git Flow 的图形界面操作</td><td><a href="https://plugins.jetbrains.com/plugin/7315-git-flow-integration" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7315-git-flow-integration</a></td></tr><tr><td>Rainbow Brackets</td><td>对各个对称括号进行着色，方便查看</td><td><a href="https://github.com/izhangzhihao/intellij-rainbow-brackets" target="_blank" rel="noopener">https://github.com/izhangzhihao/intellij-rainbow-brackets</a></td></tr><tr><td>MybatisX</td><td>mybatis 框架辅助（免费）</td><td><a href="https://plugins.jetbrains.com/plugin/10119-mybatisx" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/10119-mybatisx</a></td></tr><tr><td>Lombok Plugin</td><td>Lombok 功能辅助插件</td><td><a href="https://plugins.jetbrains.com/plugin/6317-lombok-plugin" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/6317-lombok-plugin</a></td></tr><tr><td>.ignore</td><td>各类版本控制忽略文件生成工具</td><td><a href="https://plugins.jetbrains.com/plugin/7495--ignore" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7495–ignore</a></td></tr><tr><td>mongo4idea</td><td>mongo客户端</td><td><a href="https://github.com/dboissier/mongo4idea" target="_blank" rel="noopener">https://github.com/dboissier/mongo4idea</a></td></tr><tr><td>iedis</td><td>redis客户端</td><td><a href="https://plugins.jetbrains.com/plugin/9228-iedis" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/9228-iedis</a></td></tr><tr><td>VisualVM Launcher</td><td>项目启动的时候也启动 VisualVM</td><td><a href="https://plugins.jetbrains.com/plugin/7115-visualvm-launcher" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/7115-visualvm-launcher</a></td></tr><tr><td>GenerateAllSetter</td><td>new POJO类的快速生成 set 方法</td><td><a href="https://plugins.jetbrains.com/plugin/9360-generateallsetter" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/9360-generateallsetter</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开 intellj idea  插件 搜索安装即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;activate-power-mode 装逼必备&lt;br&gt;&lt;a href=&quot;https://github.com/ViceFantasyPlace/activate-power
      
    
    </summary>
    
      <category term="tools" scheme="https://hiekay.github.io/categories/tools/"/>
    
    
      <category term="linux 小工具" scheme="https://hiekay.github.io/tags/linux-%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
      <category term="intellij idea" scheme="https://hiekay.github.io/tags/intellij-idea/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装GIMP代替photoshop</title>
    <link href="https://hiekay.github.io/2018/10/19/ubuntu%E5%AE%89%E8%A3%85GIMP%E4%BB%A3%E6%9B%BFphotoshop/"/>
    <id>https://hiekay.github.io/2018/10/19/ubuntu安装GIMP代替photoshop/</id>
    <published>2018-10-19T14:48:28.000Z</published>
    <updated>2018-10-19T14:48:52.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、安装源-（系统如果已有，则直接安装）"><a href="#1、安装源-（系统如果已有，则直接安装）" class="headerlink" title="1、安装源 （系统如果已有，则直接安装）"></a>1、安装源 （系统如果已有，则直接安装）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:otto-kesselgulasch/gimp</span><br></pre></td></tr></table></figure><h3 id="2、升级"><a href="#2、升级" class="headerlink" title="2、升级"></a>2、升级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gimp</span><br></pre></td></tr></table></figure><h3 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gimp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、安装源-（系统如果已有，则直接安装）&quot;&gt;&lt;a href=&quot;#1、安装源-（系统如果已有，则直接安装）&quot; class=&quot;headerlink&quot; title=&quot;1、安装源 （系统如果已有，则直接安装）&quot;&gt;&lt;/a&gt;1、安装源 （系统如果已有，则直接安装）&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="tools" scheme="https://hiekay.github.io/categories/tools/"/>
    
    
      <category term="linux 小工具" scheme="https://hiekay.github.io/tags/linux-%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
      <category term="gimp" scheme="https://hiekay.github.io/tags/gimp/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装xmind8,指定jdk版本</title>
    <link href="https://hiekay.github.io/2018/10/19/ubuntu%E5%AE%89%E8%A3%85xmind8-%E6%8C%87%E5%AE%9Ajdk%E7%89%88%E6%9C%AC/"/>
    <id>https://hiekay.github.io/2018/10/19/ubuntu安装xmind8-指定jdk版本/</id>
    <published>2018-10-19T14:47:20.000Z</published>
    <updated>2018-10-19T14:47:45.198Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1、下载-xmind8"><a href="#1、下载-xmind8" class="headerlink" title="1、下载 xmind8"></a>1、下载 xmind8</h5><p><a href="http://www.xmind.net/download/linux/" target="_blank" rel="noopener">http://www.xmind.net/download/linux/</a><br> <img src="https://upload-images.jianshu.io/upload_images/5110710-1608e04e5691eb2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h5 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo unzip xmind-8-update8-linux.zip -d xmind8</span><br></pre></td></tr></table></figure><h5 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  xmind8</span><br><span class="line">sudo ./setup.sh</span><br></pre></td></tr></table></figure><h5 id="4、修改权限"><a href="#4、修改权限" class="headerlink" title="4、修改权限"></a>4、修改权限</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R 777  xmind8/*</span><br></pre></td></tr></table></figure><h5 id="5、启动"><a href="#5、启动" class="headerlink" title="5、启动"></a>5、启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  xmind8/XMind_amd64 </span><br><span class="line">./XMind</span><br></pre></td></tr></table></figure><h5 id="6、如果你需要指定jdk"><a href="#6、如果你需要指定jdk" class="headerlink" title="6、如果你需要指定jdk"></a>6、如果你需要指定jdk</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim xmind/XMind_amd64/XMind.ini</span><br><span class="line">#添加</span><br><span class="line">-vm</span><br><span class="line">/home/hiekay/jdk1.8.0_181/bin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1、下载-xmind8&quot;&gt;&lt;a href=&quot;#1、下载-xmind8&quot; class=&quot;headerlink&quot; title=&quot;1、下载 xmind8&quot;&gt;&lt;/a&gt;1、下载 xmind8&lt;/h5&gt;&lt;p&gt;&lt;a href=&quot;http://www.xmind.net/down
      
    
    </summary>
    
      <category term="tools" scheme="https://hiekay.github.io/categories/tools/"/>
    
    
      <category term="linux 小工具" scheme="https://hiekay.github.io/tags/linux-%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
      <category term="xmind8" scheme="https://hiekay.github.io/tags/xmind8/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu推荐安装有用小工具</title>
    <link href="https://hiekay.github.io/2018/10/19/ubuntu%E6%8E%A8%E8%8D%90%E5%AE%89%E8%A3%85%E6%9C%89%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://hiekay.github.io/2018/10/19/ubuntu推荐安装有用小工具/</id>
    <published>2018-10-19T14:46:24.000Z</published>
    <updated>2018-10-19T14:46:58.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、albert-Ubuntu有一款类似于Mac系统Spotlight搜索的软件——Albert"><a href="#1、albert-Ubuntu有一款类似于Mac系统Spotlight搜索的软件——Albert" class="headerlink" title="1、albert (Ubuntu有一款类似于Mac系统Spotlight搜索的软件——Albert)"></a>1、albert (Ubuntu有一款类似于Mac系统Spotlight搜索的软件——Albert)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:nilarimogard/webupd8 </span><br><span class="line">sudo apt update </span><br><span class="line">sudo apt install albert</span><br><span class="line">#运行</span><br><span class="line">albert &amp;</span><br></pre></td></tr></table></figure><h3 id="2、安装indicator-sysmonitor实现导航条显示上下行网速-CPU-内存使用率"><a href="#2、安装indicator-sysmonitor实现导航条显示上下行网速-CPU-内存使用率" class="headerlink" title="2、安装indicator-sysmonitor实现导航条显示上下行网速/CPU/内存使用率"></a>2、安装indicator-sysmonitor实现导航条显示上下行网速/CPU/内存使用率</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor  </span><br><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install indicator-sysmonitor </span><br><span class="line">#运行</span><br><span class="line">indicator-sysmonitor &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、albert-Ubuntu有一款类似于Mac系统Spotlight搜索的软件——Albert&quot;&gt;&lt;a href=&quot;#1、albert-Ubuntu有一款类似于Mac系统Spotlight搜索的软件——Albert&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="tools" scheme="https://hiekay.github.io/categories/tools/"/>
    
    
      <category term="linux 小工具" scheme="https://hiekay.github.io/tags/linux-%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Albert" scheme="https://hiekay.github.io/tags/Albert/"/>
    
  </entry>
  
  <entry>
    <title>最好用的markdown编辑器推荐typora</title>
    <link href="https://hiekay.github.io/2018/10/19/%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84markdown%E7%BC%96%E8%BE%91%E5%99%A8%E6%8E%A8%E8%8D%90typora/"/>
    <id>https://hiekay.github.io/2018/10/19/最好用的markdown编辑器推荐typora/</id>
    <published>2018-10-19T14:45:01.000Z</published>
    <updated>2018-10-19T14:45:54.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h3><p><a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a><br><img src="https://upload-images.jianshu.io/upload_images/5110710-154b8dfec6340534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>选择适合自己的系统。</p><h3 id="2、安装-小编用的是linux"><a href="#2、安装-小编用的是linux" class="headerlink" title="2、安装 小编用的是linux"></a>2、安装 小编用的是linux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># optional, but recommended</span><br><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line"># add Typora&apos;s repository</span><br><span class="line">sudo add-apt-repository &apos;deb https://typora.io/linux ./&apos;</span><br><span class="line">sudo apt-get update</span><br><span class="line"># install typora</span><br><span class="line">sudo apt-get install typora</span><br></pre></td></tr></table></figure><h3 id="3、运行"><a href="#3、运行" class="headerlink" title="3、运行"></a>3、运行</h3><blockquote><p>pypora</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、下载&quot;&gt;&lt;a href=&quot;#1、下载&quot; class=&quot;headerlink&quot; title=&quot;1、下载&quot;&gt;&lt;/a&gt;1、下载&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://typora.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ht
      
    
    </summary>
    
      <category term="tools" scheme="https://hiekay.github.io/categories/tools/"/>
    
    
      <category term="linux 小工具" scheme="https://hiekay.github.io/tags/linux-%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
      <category term="typora" scheme="https://hiekay.github.io/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装监控系统软件工具netdata</title>
    <link href="https://hiekay.github.io/2018/10/19/ubuntu%E5%AE%89%E8%A3%85%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7netdata/"/>
    <id>https://hiekay.github.io/2018/10/19/ubuntu安装监控系统软件工具netdata/</id>
    <published>2018-10-19T14:40:30.000Z</published>
    <updated>2018-10-19T14:44:02.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h1><p>地址：<a href="https://github.com/firehol/netdata，也可以使用git：git" target="_blank" rel="noopener">https://github.com/firehol/netdata，也可以使用git：git</a> clone <a href="https://github.com/firehol/netdata.git" target="_blank" rel="noopener">https://github.com/firehol/netdata.git</a> –depth=1</p><h1 id="2、安装依赖"><a href="#2、安装依赖" class="headerlink" title="2、安装依赖"></a>2、安装依赖</h1><blockquote><p>sudo apt-get install zlib1g-dev gcc make git autoconf autogen automake pkg-config uuid-dev </p></blockquote><h1 id="3、安装netdata"><a href="#3、安装netdata" class="headerlink" title="3、安装netdata"></a>3、安装netdata</h1><p>进入下载netdata文件目录</p><blockquote><p>sudo ./netdata-installer.sh   </p></blockquote><h1 id="4、使用"><a href="#4、使用" class="headerlink" title="4、使用"></a>4、使用</h1><p>访问地址： <a href="http://127.0.0.1:19999/" target="_blank" rel="noopener">http://127.0.0.1:19999/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、下载&quot;&gt;&lt;a href=&quot;#1、下载&quot; class=&quot;headerlink&quot; title=&quot;1、下载&quot;&gt;&lt;/a&gt;1、下载&lt;/h1&gt;&lt;p&gt;地址：&lt;a href=&quot;https://github.com/firehol/netdata，也可以使用git：git&quot; t
      
    
    </summary>
    
      <category term="tools" scheme="https://hiekay.github.io/categories/tools/"/>
    
    
      <category term="linux 小工具" scheme="https://hiekay.github.io/tags/linux-%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
      <category term="netdata" scheme="https://hiekay.github.io/tags/netdata/"/>
    
  </entry>
  
  <entry>
    <title>kibana安装使用</title>
    <link href="https://hiekay.github.io/2018/10/18/kibana%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://hiekay.github.io/2018/10/18/kibana安装使用/</id>
    <published>2018-10-18T14:25:07.000Z</published>
    <updated>2018-10-18T14:25:35.660Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h3><p><a href="https://www.elastic.co/cn/products/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/products/kibana</a></p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><blockquote><p>tar -zxvf kibanaxxx.tar.gz<br>cd kibana_HOME </p></blockquote><h3 id="三、修改配置"><a href="#三、修改配置" class="headerlink" title="三、修改配置"></a>三、修改配置</h3><blockquote><p>vim config/kibana.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将默认配置改成如下：</span><br><span class="line"></span><br><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.url: &quot;http://127.0.0.1:9201&quot;    //修改成自己集群的端口号</span><br><span class="line">kibana.index: &quot;.kibana&quot;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="四、运行-启动"><a href="#四、运行-启动" class="headerlink" title="四、运行 启动"></a>四、运行 启动</h3><blockquote><p>bin/kibana</p></blockquote><p>启动后打开浏览器访问 <a href="http://127.0.0.1:5601/" target="_blank" rel="noopener">http://127.0.0.1:5601</a> 浏览 kibana 界面：<br><img src="https://upload-images.jianshu.io/upload_images/5110710-b034f24d8f30f846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="五、演示"><a href="#五、演示" class="headerlink" title="五、演示"></a>五、演示</h3><p>上图中，提示不能获取映射，即 Elasticsearch 中的索引。我们需要手动配置。在 Index Pattern 下边的输入框中输入 syslog-*，它是 Elasticsearch 中的一个索引名称开头。(syslog是我已经创建好的index)</p><p>Kibana 会自动检测在 Elasticsearch 中是否存在该索引名称，如果有，则下边出现 “Create” 按钮，我们点击进行创建并来到如下界面：<br><img src="https://upload-images.jianshu.io/upload_images/5110710-5ab4304d9e755492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>1、Discovery<br>“Discovery” 菜单界面主要用于通过搜索请求，过滤结果，查看文档数据。可以查询搜索请求的文档总数，获取字段值的统计情况并通过柱状图进行展示。<br>点击左侧 “Discovery” 菜单，来到如下界面：<br><img src="https://upload-images.jianshu.io/upload_images/5110710-566907e5a3200922.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>2、Visualize<br>“Visualize” 菜单界面主要用于将查询出的数据进行可视化展示，且可以将其保存或加载合并到 Dashboard 中。<br>点击左侧 “Visualize” 菜单，再点击界面中间的 “Create a visualization” 按钮来到如下界面：<br><img src="https://upload-images.jianshu.io/upload_images/5110710-f047c6bc33d440e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>本次测试选择柱状图演示，点击柱状图：<br><img src="https://upload-images.jianshu.io/upload_images/5110710-54ff70189ddb53eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>点击右上角“Save” 按钮可以进行保存。笔者将该可视化保存为 “syslog access”。</li><li>3、Dashboard<br>在“Dashboard” 菜单界面中，我们可以自由排列一组已保存的可视化数据。<br>点击左侧 “Dashboard” 菜单，再点击界面中间的 “Create a dashboard” 按钮进行创建：<br><img src="https://upload-images.jianshu.io/upload_images/5110710-303d3bded42142ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>4、Timelion<br>Timelion 是一个时间序列数据的可视化，可以结合在一个单一的可视化完全独立的数据源。它是由一个简单的表达式语言驱动的，用来检索时间序列数据，进行计算，找出复杂的问题的答案，并可视化的结果。<br><img src="https://upload-images.jianshu.io/upload_images/5110710-f4eb1f51df922a10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li><p>5、APM<br>应用程序性能监视（APM）从应用程序内部收集深入的性能指标和错误。它允许您实时监控数千个应用程序的性能。<br>需要先安装apm server 和agent , 移步去看小编另一篇博文<a href="https://www.jianshu.com/p/bbc9ce0d963c" target="_blank" rel="noopener">apm server</a><br><img src="https://upload-images.jianshu.io/upload_images/5110710-9133714a16a7dcc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>6、Dev Tools<br>“Dev Tools” 菜单界面使用户方便的通过浏览器直接与 Elasticsearch 进行交互，发送 RESTFUL 请求可以对 Elasticsearch 数据进行增删改查：<br><img src="https://upload-images.jianshu.io/upload_images/5110710-d2c6556219b9d32b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li>7 Monitoring<br>监控系统<br><img src="https://upload-images.jianshu.io/upload_images/5110710-93b8ed24b0d0dc96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、下载&quot;&gt;&lt;a href=&quot;#一、下载&quot; class=&quot;headerlink&quot; title=&quot;一、下载&quot;&gt;&lt;/a&gt;一、下载&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/cn/products/kibana&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="elasticsearch" scheme="https://hiekay.github.io/categories/elasticsearch/"/>
    
    
      <category term="ubuntu elasticsearch" scheme="https://hiekay.github.io/tags/ubuntu-elasticsearch/"/>
    
      <category term="kibana" scheme="https://hiekay.github.io/tags/kibana/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装APMAgents</title>
    <link href="https://hiekay.github.io/2018/10/18/ubuntu%E5%AE%89%E8%A3%85APMAgents/"/>
    <id>https://hiekay.github.io/2018/10/18/ubuntu安装APMAgents/</id>
    <published>2018-10-18T14:24:33.000Z</published>
    <updated>2018-10-18T14:24:50.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、将Node-js的APM代理安装为应用程序的依赖项。"><a href="#1、将Node-js的APM代理安装为应用程序的依赖项。" class="headerlink" title="1、将Node.js的APM代理安装为应用程序的依赖项。"></a>1、将Node.js的APM代理安装为应用程序的依赖项。</h1><blockquote><p>npm install elastic-apm-node –save</p></blockquote><h1 id="2、配置agent"><a href="#2、配置agent" class="headerlink" title="2、配置agent"></a>2、配置agent</h1><p>代理是在应用程序进程内运行的库。APM服务是基于serviceName以编程方式创建的。此代理支持Express，Koa，hapi和自定义Node.js.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Add this to the VERY top of the first file loaded in your app</span><br><span class="line">var apm = require(&apos;elastic-apm-node&apos;).start(&#123;</span><br><span class="line">  // Set required service name (allowed characters: a-z, A-Z, 0-9, -, _, and space)</span><br><span class="line">  serviceName: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  // Use if APM Server requires a token</span><br><span class="line">  secretToken: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  // Set custom APM Server URL (default: http://localhost:8200)</span><br><span class="line">  serverUrl: &apos;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、将Node-js的APM代理安装为应用程序的依赖项。&quot;&gt;&lt;a href=&quot;#1、将Node-js的APM代理安装为应用程序的依赖项。&quot; class=&quot;headerlink&quot; title=&quot;1、将Node.js的APM代理安装为应用程序的依赖项。&quot;&gt;&lt;/a&gt;1、
      
    
    </summary>
    
      <category term="elasticsearch" scheme="https://hiekay.github.io/categories/elasticsearch/"/>
    
    
      <category term="ubuntu elasticsearch" scheme="https://hiekay.github.io/tags/ubuntu-elasticsearch/"/>
    
      <category term="elasticsearch" scheme="https://hiekay.github.io/tags/elasticsearch/"/>
    
  </entry>
  
</feed>
